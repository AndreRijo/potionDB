package crdt

import (
	"fmt"
	"math"
	"potionDB/src/clocksi"
	"potionDB/src/proto"
	"sort"

	pb "github.com/golang/protobuf/proto"
)

//TODO: On benchmarks/tests, ToUpdateObject() wasn't storing the *data.
//TODO: updsNotYetApplied

type TopKRmvCrdt struct {
	*genericInversibleCRDT
	vc        clocksi.Timestamp
	replicaID int16

	//Max number of elements that can be in top-K
	maxElems int
	//Max number of elements to have in the shadow top
	maxShadowElems int
	//The "smallest score" in the top-K. Useful to know if when a new add arrives it should be added to the top or "hidden" to notInTop
	minTop    TopKElement
	shadowMin TopKElement
	//Elements that are in the top-K
	elems map[int32]TopKElement
	//Element that are in the shadow top. Elements here are also fully replicated just like top elements.
	shadowTop map[int32]setTopKElement
	//Removes of all elements, both in and not in top-K
	rems map[int32]clocksi.Timestamp
	//Elems for which either:
	//a) the value is < minTop and thus shouldn't be in top
	//b) the value is >= minTop yet a higher value for the same ID is already on top, albeit with a smaller TS.
	notInTop map[int32]setTopKElement

	//Buffer for getTopN and getTopAbove.
	//Each time the top is modified it gets nilled, and is rebuilt on the first execution of one of those queries.
	//Note that changes to notInTop DOES NOT nil this buffer.
	sortedElems []TopKScore
}

type TopKValueState struct {
	Scores []TopKScore
}

type TopKAdd struct {
	TopKScore
}

type TopKAddAll struct {
	Scores []TopKScore
}

type TopKRemove struct {
	Id int32
}

type TopKRemoveAll struct {
	Ids []int32
}

//Used to set the top's size with a value different from the default. It is expected for this operation to be the first one of all.
type TopKInit struct {
	TopSize       uint32
	ShadowTopSize int32 //If -1, the CRDT itself will decide its size
}

type DownstreamTopKAdd struct {
	TopKElement
}

//Idea: Has two slices: one for updates that must be propagated and the other for fault-tolerance purposes
//The second is never propagated (as of now).
//MustReplicate() returns true if the first slice has at least one element, independently of the state of the second slice.
//However, the second slice is never included in the protobufs, thus ensuring that only the first slice is propagated.
//If the first slice is empty, MustReplicate() returns false and thus no downstream is sent to other replicas.
type DownstreamTopKAddAll struct {
	DownstreamAdds    []TopKElement
	OptDownstreamAdds []TopKElement
}

type DownstreamTopKRemove struct {
	Id int32
	Vc clocksi.Timestamp
}

//Same idea as in DownstreamTopKAddAll
type DownstreamTopKRemoveAll struct {
	Vc          []clocksi.Timestamp //Only 1 entry when generated by TopKRemoveAll; as many entries as DownRems when generated by DownstreamTopKAddAll
	DownRems    []int32
	OptDownRems []int32
}

//A topkadd that doesn't necessarily need to be replicated for other than fault-tolerance purposes
type OptDownstreamTopKAdd struct {
	DownstreamTopKAdd
}

//A topkrmv that doesn't necessarily need to be replicated for other than fault-tolerance purposes
type OptDownstreamTopKRemove struct {
	DownstreamTopKRemove
}

//Queries
type GetTopNArguments struct {
	NumberEntries int32
}

type GetTopKAboveValueArguments struct {
	MinValue int32
}

type TopKScore struct {
	Id    int32
	Score int32
	Data  *[]byte
}

type TopKElement struct {
	Id        int32
	Score     int32
	Ts        int64
	ReplicaID int16
	Data      *[]byte
}

//List of TopKAddEffect, TopKAddNotTopEffect and TopKReplaceEffect
type TopKAddAllEffect struct {
	effects []*Effect
}

//Effect of an TopKAdd that adds the element to the top
type TopKAddEffect struct {
	TopKElement
	oldTs int64 //Used to make the crdt's VC go "back in time"
}

//Effect of an TopKAdd that adds the element to notInTop
type TopKAddNotTopEffect struct {
	TopKAddEffect
}

//Effect of an TopKAdd which replaced an older, lower value with a higher one, possibly changing the min.
type TopKReplaceEffect struct {
	newElem TopKElement
	oldElem TopKElement
	oldMin  TopKElement
	oldTs   int64 //Used to make the crdt's VC go "back in time"
}

type TopKRemoveAllEffect struct {
	effects []*TopKRemoveEffect
}

type TopKRemoveEffect struct {
	id            int32
	previousVc    clocksi.Timestamp //nil in case there wasn't a previous remove for this Id
	notTopRemoved setTopKElement
	remElem       TopKElement
	oldMin        TopKElement
	minAddedToTop bool //true if oldMin was updated to the top
}

type setTopKElement map[TopKElement]struct{}
type setOps map[UpdateArguments]struct{}

func makeEmptyTopKElement() TopKElement {
	//return TopKElement{Id: math.MinInt32, Score: math.MinInt32}
	return TopKElement{}
}

//Adds an element to the set. This hides the internal representation of the set
func (set setTopKElement) add(elem TopKElement) {
	set[elem] = struct{}{}
}

func (set setTopKElement) addAll(elems setTopKElement) {
	for elem := range elems {
		set[elem] = struct{}{}
	}
}

func (set setTopKElement) copy() (newSet setTopKElement) {
	newSet = make(setTopKElement)
	for id, elem := range set {
		newSet[id] = elem
	}
	return
}

func (set setOps) add(op UpdateArguments) {
	set[op] = struct{}{}
}

//Returns true if elem is > than other
func (elem TopKElement) isHigher(other TopKElement) bool {
	if (other.isEqual(TopKElement{})) {
		return true
	}
	if elem.Score > other.Score {
		return true
	}
	//Same scores. First, compare IDs. If the IDs are also equivalent, then compare timestamps.
	if elem.Score == other.Score {
		if elem.Id > other.Id {
			return true
		}
		if elem.Id == other.Id && elem.Ts > other.Ts {
			return true
		}
	}
	return false
}

func (elem TopKElement) isSmaller(other TopKElement) bool {
	return other.isEqual(TopKElement{}) || other.isHigher(elem)
}

func (elem TopKElement) isEqual(other TopKElement) bool {
	return elem.Id == other.Id && elem.ReplicaID == other.ReplicaID &&
		elem.Score == other.Score && elem.Ts == other.Ts
}

func (crdt *TopKRmvCrdt) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

//Ops
func (args TopKInit) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args TopKAdd) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args TopKAddAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args TopKRemove) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args TopKRemoveAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

//Downstreams
func (args DownstreamTopKAdd) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args DownstreamTopKAddAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args DownstreamTopKRemove) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args DownstreamTopKRemoveAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args OptDownstreamTopKAdd) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args OptDownstreamTopKRemove) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args TopKInit) MustReplicate() bool { return true }

func (args DownstreamTopKAdd) MustReplicate() bool { return true }

func (args DownstreamTopKAddAll) MustReplicate() bool { return len(args.DownstreamAdds) > 0 }

func (args DownstreamTopKRemove) MustReplicate() bool { return true }

func (args DownstreamTopKRemoveAll) MustReplicate() bool { return len(args.DownRems) > 0 }

func (args OptDownstreamTopKAdd) MustReplicate() bool { return false }

func (args OptDownstreamTopKRemove) MustReplicate() bool { return false }

//States
func (args TopKValueState) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args TopKValueState) GetREADType() proto.READType { return proto.READType_FULL }

//Reads
func (args GetTopNArguments) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args GetTopNArguments) GetREADType() proto.READType { return proto.READType_GET_N }

func (args GetTopKAboveValueArguments) GetCRDTType() proto.CRDTType { return proto.CRDTType_TOPK_RMV }

func (args GetTopKAboveValueArguments) GetREADType() proto.READType {
	return proto.READType_GET_ABOVE_VALUE
}

const (
	cacheSortedSet = true //If topN query should cache the sorted set of elems until an update is applied
)

var (
	defaultTopKSize       = 100 //Default number of top positions
	defaultTopKShadowSize = 20
)

func (crdt *TopKRmvCrdt) Initialize(startTs *clocksi.Timestamp, replicaID int16) (newCrdt CRDT) {
	return crdt.InitializeWithSize(startTs, replicaID, defaultTopKSize, defaultTopKShadowSize)
}

func (crdt *TopKRmvCrdt) InitializeWithSize(startTs *clocksi.Timestamp, replicaID int16, size, shadowSize int) (newCrdt CRDT) {
	crdt = &TopKRmvCrdt{
		genericInversibleCRDT: (&genericInversibleCRDT{}).initialize(startTs),
		vc:                    clocksi.NewClockSiTimestamp(),
		//vc:                    clocksi.NewClockSiTimestamp(replicaID),
		replicaID:      replicaID,
		maxElems:       size,
		maxShadowElems: shadowSize,
		//minTop:         TopKElement{Score: math.MinInt32},
		minTop:    makeEmptyTopKElement(),
		shadowMin: makeEmptyTopKElement(),
		elems:     make(map[int32]TopKElement, size),
		shadowTop: make(map[int32]setTopKElement, shadowSize),
		rems:      make(map[int32]clocksi.Timestamp),
		notInTop:  make(map[int32]setTopKElement, size),
	}
	newCrdt = crdt
	return
}

//Used to initialize when building a CRDT from a remote snapshot
func (crdt *TopKRmvCrdt) initializeFromSnapshot(startTs *clocksi.Timestamp, replicaID int16) (sameCRDT *TopKRmvCrdt) {
	crdt.genericInversibleCRDT, crdt.replicaID = (&genericInversibleCRDT{}).initialize(startTs), replicaID
	return crdt
}

func (crdt *TopKRmvCrdt) Read(args ReadArguments, updsNotYetApplied []*UpdateArguments) (state State) {
	//TODO: Consider updsNotYetApplied in all of these
	switch typedArgs := args.(type) {
	case StateReadArguments:
		return crdt.getState(updsNotYetApplied)
	case GetTopNArguments:
		return crdt.getTopN(typedArgs.NumberEntries, updsNotYetApplied)
	case GetTopKAboveValueArguments:
		return crdt.getTopKAboveValue(typedArgs.MinValue, updsNotYetApplied)
	default:
		fmt.Printf("[TOPKCrdt]Unknown read type: %+v\n", args)
	}
	return nil
}

func (crdt *TopKRmvCrdt) getState(updsNotYetApplied []*UpdateArguments) (state State) {
	values := make([]TopKScore, len(crdt.elems))
	i := 0
	for _, elem := range crdt.elems {
		values[i] = TopKScore{Id: elem.Id, Score: elem.Score, Data: elem.Data}
		i++
	}
	return TopKValueState{Scores: values}
}

/*
	Note: in the current implementation, at most N entries are returned, even if N+1 has the same value as N.
*/
func (crdt *TopKRmvCrdt) getTopN(numberEntries int32, updsNotYetApplied []*UpdateArguments) (state State) {
	/*
		values := make([]TopKScore, numberEntries, numberEntries)
		i := int32(0)
		for _, elem := range crdt.elems {
			values[i] = TopKScore{Id: elem.Id, Score: elem.Score, Data: elem.Data}
			i++
			if i == numberEntries {
				break
			}
		}
		return TopKValueState{Scores: values}
	*/
	if crdt.sortedElems == nil {
		//TODO: May be an issue when updsNotYetApplied get considered.
		crdt.sortedElems = crdt.getState(updsNotYetApplied).(TopKValueState).Scores
		sort.Slice(crdt.sortedElems, func(i, j int) bool { return crdt.sortedElems[i].Score > crdt.sortedElems[j].Score })
	}
	if numberEntries >= int32(len(crdt.sortedElems)) {
		//TODO: Should I include notInTop?
		return TopKValueState{Scores: crdt.sortedElems}
	}
	return TopKValueState{Scores: crdt.sortedElems[:numberEntries]}
}

func (crdt *TopKRmvCrdt) getTopKAboveValue(minValue int32, updsNotYetApplied []*UpdateArguments) (state State) {
	values := make([]TopKScore, len(crdt.elems))
	actuallyAdded := 0
	//Faster to do with sortedElems if it's available.
	if crdt.sortedElems != nil {
		for _, elem := range crdt.sortedElems {
			if elem.Score >= minValue {
				values[actuallyAdded] = TopKScore{Id: elem.Id, Score: elem.Score, Data: elem.Data}
				actuallyAdded++
			} else {
				break
			}
		}
	} else {
		//Must go through all elems
		for _, elem := range crdt.elems {
			if elem.Score >= minValue {
				values[actuallyAdded] = TopKScore{Id: elem.Id, Score: elem.Score, Data: elem.Data}
				actuallyAdded++
			}
		}
	}

	return TopKValueState{Scores: values[:actuallyAdded]}
}

func (crdt *TopKRmvCrdt) Update(args UpdateArguments) (downstreamArgs DownstreamArguments) {
	//add, rmv: needs to be propagated. add_r, rmv_r - *may* need to be propagated later depending on the operations that are executed in other replicas.
	//or actually, the _r version may be the one that is replicated to the other replicas for fault tolerance? Need to ask that
	//E.g of add_r: consider the operations: add(10, 10, 0), add(10, 5, 5). Now consider that another replica did rem(10) after receiving the first add.
	//In this case, the 2nd add would then be relevant and need to be propagated.

	switch opType := args.(type) {
	case TopKAdd:
		downstreamArgs = crdt.getTopKAddDownstreamArgs(&opType)
	case TopKRemove:
		//Ensuring that the VC of the update and of the CRDT are different instances in order to avoid modifying the upd's accidentally.
		downstreamArgs = crdt.getTopKRemoveDownstreamArgs(&opType)
	case TopKAddAll:
		downstreamArgs = crdt.getTopKAddAllDownstreamArgs(&opType)
	case TopKRemoveAll:
		downstreamArgs = crdt.getTopKRemoveAllDownstreamArgs(&opType)
	case TopKInit:
		downstreamArgs = opType
	}
	return
}

func (crdt *TopKRmvCrdt) getTopKAddDownstreamArgs(addOp *TopKAdd) (args DownstreamArguments) {
	crdt.vc.SelfIncTimestamp(crdt.replicaID)
	elem, hasId := crdt.elems[addOp.Id]
	localArgs := DownstreamTopKAdd{TopKElement: TopKElement{Id: addOp.Id, Score: addOp.Score, Ts: crdt.vc.GetPos(crdt.replicaID), ReplicaID: crdt.replicaID, Data: addOp.Data}}
	if addOp.Data == nil {
		localArgs.Data = &[]byte{}
	}
	//Check if this element should belong to the top/shadow top or not
	//An element should belong to the top iff one of those are true:
	//1) Its id is already in the Top but with a smaller score
	//2) Its id is not in the top but it is higher than the minTop
	//If an element belongs to the top, then a normal TopKAdd must be returned. Otherwise, a "TopKAdd_r" is returned.
	if hasId && elem.Score <= addOp.Score {
		//1st
		args = localArgs
	} else if hasId { //Check shadowTop
		if localArgs.isHigher(crdt.shadowMin) {
			args = localArgs
		} else if _, hasId = crdt.shadowTop[addOp.Id]; hasId {
			args = localArgs
		} else {
			//add_r
			args = OptDownstreamTopKAdd{DownstreamTopKAdd: localArgs}
		}
	} else {
		//2nd, i.e., !hasId
		if localArgs.isHigher(crdt.minTop) {
			args = localArgs
		} else { //Check shadowMin
			if localArgs.isHigher(crdt.shadowMin) {
				args = localArgs
			} else if _, hasId = crdt.shadowTop[addOp.Id]; hasId {
				args = localArgs
			} else {
				//add_r
				args = OptDownstreamTopKAdd{DownstreamTopKAdd: localArgs}
			}
		}
	}
	return
}

/* 	A few points worth noting/current limitations:
Doesn't support "Opt". That is, all adds which are for fault tolerance purposes only are ignored.
The current workings of this method lead to more adds than necessary being downstreamed, since the old min is always used as a reference.
	For the latter, the same exact problem happens when executing multiple TopKAdd in the same txn.
*/
func (crdt *TopKRmvCrdt) getTopKAddAllDownstreamArgs(addOp *TopKAddAll) (args DownstreamArguments) {
	crdt.vc.SelfIncTimestamp(crdt.replicaID)
	localClk := crdt.vc.GetPos(crdt.replicaID)
	nAdd, nOpt := 0, 0
	downAdds, optDownAdds := make([]TopKElement, len(addOp.Scores)), make([]TopKElement, len(addOp.Scores))
	var existingElem, currElem TopKElement = TopKElement{}, TopKElement{}
	hasId := false
	for _, add := range addOp.Scores {
		existingElem, hasId = crdt.elems[add.Id]
		currElem = TopKElement{Id: add.Id, Score: add.Score, Ts: localClk, ReplicaID: crdt.replicaID, Data: add.Data}
		if add.Data == nil {
			currElem.Data = &[]byte{}
		}
		if hasId && existingElem.Score <= add.Score {
			downAdds[nAdd] = currElem
			nAdd++
		} else if hasId { //Check shadowTop
			if currElem.isHigher(crdt.shadowMin) {
				downAdds[nAdd] = currElem
				nAdd++
			} else if _, hasId = crdt.shadowTop[add.Id]; hasId {
				downAdds[nAdd] = currElem
				nAdd++
			} else {
				optDownAdds[nOpt] = currElem
				nOpt++
			}
		} else {
			if currElem.isHigher(crdt.minTop) {
				downAdds[nAdd] = currElem
				nAdd++
			} else { //Check shadowTop
				if currElem.isHigher(crdt.shadowMin) {
					downAdds[nAdd] = currElem
					nAdd++
				} else if _, hasId = crdt.shadowTop[add.Id]; hasId {
					downAdds[nAdd] = currElem
					nAdd++
				} else {
					optDownAdds[nOpt] = currElem
					nOpt++
				}
			}
		}
	}
	return DownstreamTopKAddAll{DownstreamAdds: downAdds[0:nAdd], OptDownstreamAdds: optDownAdds[0:nOpt]}
}

func (crdt *TopKRmvCrdt) getTopKRemoveDownstreamArgs(remOp *TopKRemove) (args DownstreamArguments) {
	//Check if ID is in the topK or in the "notInTop"
	_, inElems := crdt.elems[remOp.Id]
	_, inShadow := crdt.shadowTop[remOp.Id]
	_, inNotTop := crdt.notInTop[remOp.Id]
	if !inElems && !inShadow && !inNotTop {
		//This remove is irrelevant as this ID isn't in the top and never will be until a more recent add appears
		args = NoOp{}
	} else if inElems || inShadow {
		//Remove for element in top-k. Must be propagated
		//Ensuring that the VC of the update and of the CRDT are different instances in order to avoid modifying the upd's accidentally.
		args = DownstreamTopKRemove{Id: remOp.Id, Vc: crdt.vc.Copy()}
	} else {
		//inNotTop = true
		//rmv_r
		args = OptDownstreamTopKRemove{DownstreamTopKRemove: DownstreamTopKRemove{Id: remOp.Id, Vc: crdt.vc.Copy()}}
		//args = DownstreamTopKRemove{Id: remOp.Id, Vc: crdt.vc.Copy()}
	}
	return
}

//TODO: This is not 100% correct, as when some elements are removed from the top, others in notInTop get promoted to top.
//Some removes in TopKRemoveAll may refer to such promoted elements and, with the current implementation, they would end in OptDownRems instead of DownRems
//This also leads to possibly more adds being generated than the length of downRems.
func (crdt *TopKRmvCrdt) getTopKRemoveAllDownstreamArgs(remOp *TopKRemoveAll) (args DownstreamArguments) {
	inElems, inShadow, inNotTop := false, false, false
	nRem, nOpt := 0, 0
	removesDown := DownstreamTopKRemoveAll{DownRems: make([]int32, len(remOp.Ids)),
		OptDownRems: make([]int32, len(remOp.Ids))}

	for _, id := range remOp.Ids {
		_, inElems = crdt.elems[id]
		_, inShadow = crdt.shadowTop[id]
		_, inNotTop = crdt.notInTop[id]
		if inElems || inShadow {
			removesDown.DownRems[nRem] = id
			nRem++
		} else if inNotTop {
			removesDown.OptDownRems[nOpt] = id
			nOpt++
		}
		//else: Irrelevant, and this ID isn't in the top and never will be until a more revent add appears
	}
	if nRem == 0 && nOpt == 0 {
		return NoOp{}
	}
	removesDown.Vc = []clocksi.Timestamp{crdt.vc.Copy()}
	removesDown.DownRems, removesDown.OptDownRems = removesDown.DownRems[0:nRem], removesDown.OptDownRems[0:nOpt]
	return removesDown
}

func (crdt *TopKRmvCrdt) Downstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments) (otherDownstreamArgs DownstreamArguments) {
	effect, otherDownstreamArgs := crdt.applyDownstream(downstreamArgs)
	//Necessary for inversibleCrdt
	crdt.addToHistory(&updTs, &downstreamArgs, effect)
	return
}

func (crdt *TopKRmvCrdt) applyDownstream(downstreamArgs UpdateArguments) (effect *Effect, otherDownstreamArgs DownstreamArguments) {
	switch opType := downstreamArgs.(type) {
	case DownstreamTopKAdd:
		effect, otherDownstreamArgs = crdt.applyAdd(&opType)
	case DownstreamTopKRemove:
		effect, otherDownstreamArgs = crdt.applyRemove(&opType)
	//Local replicas must still apply these
	case OptDownstreamTopKAdd:
		effect, otherDownstreamArgs = crdt.applyAdd(&opType.DownstreamTopKAdd)
	case OptDownstreamTopKRemove:
		effect, otherDownstreamArgs = crdt.applyRemove(&opType.DownstreamTopKRemove)
	case DownstreamTopKAddAll:
		effect, otherDownstreamArgs = crdt.applyAddAll(&opType)
	case DownstreamTopKRemoveAll:
		effect, otherDownstreamArgs = crdt.applyRemoveAll(&opType)
	case TopKInit:
		effect, otherDownstreamArgs = crdt.applyInit(&opType)
	}
	return
}

func (crdt *TopKRmvCrdt) applyInit(op *TopKInit) (effect *Effect, otherDownstreamArgs DownstreamArguments) {
	crdt.maxElems = int(op.TopSize)
	if op.ShadowTopSize <= 0 {
		crdt.maxShadowElems = crdt.maxElems / 5
	} else {
		crdt.maxShadowElems = int(op.ShadowTopSize)
	}
	fmt.Printf("[TOPKRmv]Set top sizes to (%d, %d)\n", crdt.maxElems, crdt.maxShadowElems)
	var effectValue Effect = NoEffect{}
	effect = &effectValue
	//TODO (potencially): consider giving support for this operation if there is already elements in the top.
	return
}

func (crdt *TopKRmvCrdt) applyAddAll(op *DownstreamTopKAddAll) (effect *Effect, otherDownstreamArgs DownstreamArguments) {
	//All elems have the same ts and replicaID
	var firstElem TopKElement
	if len(op.DownstreamAdds) > 0 {
		firstElem = op.DownstreamAdds[0]
	} else {
		//May happen when applying locally the adds, as all the received values may be too small for the topK
		firstElem = op.OptDownstreamAdds[0]
	}
	oldTs := crdt.vc.GetPos(firstElem.ReplicaID)
	crdt.vc.UpdatePos(firstElem.ReplicaID, firstElem.Ts)
	listEffect := TopKAddAllEffect{effects: make([]*Effect, len(op.DownstreamAdds)+len(op.OptDownstreamAdds))}
	downRemoves := DownstreamTopKRemoveAll{Vc: make([]clocksi.Timestamp, len(op.DownstreamAdds)), DownRems: make([]int32, len(op.DownstreamAdds))}
	nRemoves, nEffects := 0, 0

	currAdds := op.DownstreamAdds
	//Must apply both down and opt (if the latter is even present)
	//Simple for to execute the same set of operations for both down and opt.
	for i := 0; i < 2; i++ {
		for _, newElem := range currAdds {
			var effectValue Effect
			if newElem.Data == nil {
				newElem.Data = &[]byte{}
			}

			remsVc, hasEntry := crdt.rems[newElem.Id]
			if !hasEntry || remsVc.GetPos(newElem.ReplicaID) < newElem.Ts {
				elem, hasId := crdt.elems[newElem.Id]
				if hasId {
					effectValue = crdt.addOpHasIdInTop(elem, newElem, oldTs)
				} else {
					effectValue = crdt.addOpNotHasIdInTop(newElem, oldTs)
				}

			} else {
				//Must return this remove to propagate to other replicas
				downRemoves.DownRems[nRemoves] = newElem.Id
				downRemoves.Vc[nRemoves] = remsVc
				nRemoves++
				effectValue = NoEffect{}
				fmt.Println("[TOPKRMV]Apply add is returning a new remove.")
			}
			listEffect.effects[nEffects] = &effectValue
			nEffects++
		}

		currAdds = op.OptDownstreamAdds
	}

	var effectI Effect = listEffect
	if nRemoves == 0 {
		return &effectI, nil
	}
	downRemoves.DownRems, downRemoves.Vc = downRemoves.DownRems[0:nRemoves], downRemoves.Vc[0:nRemoves]
	return &effectI, downRemoves
}

//Effect addToTop (include previousMin and previousEntry, if any)?
//Effect addToNotTop
func (crdt *TopKRmvCrdt) applyAdd(op *DownstreamTopKAdd) (effect *Effect, otherDownstreamArgs DownstreamArguments) {
	//fmt.Println("Applying topK add")
	var effectValue Effect
	oldTs := crdt.vc.GetPos(op.ReplicaID)
	if op.Data == nil {
		op.Data = &[]byte{}
	}

	crdt.vc.UpdatePos(op.ReplicaID, op.Ts)
	remsVc, hasEntry := crdt.rems[op.Id]
	if !hasEntry || remsVc.GetPos(op.ReplicaID) < op.Ts {
		elem, hasId := crdt.elems[op.Id]
		if hasId {
			effectValue = crdt.addOpHasIdInTop(elem, op.TopKElement, oldTs)
		} else {
			effectValue = crdt.addOpNotHasIdInTop(op.TopKElement, oldTs)
		}
	} else {
		//Must return this remove to propagate to other replicas
		otherDownstreamArgs = DownstreamTopKRemove{Id: op.Id, Vc: remsVc}
		effectValue = NoEffect{}
		fmt.Println("[TOPKRMV]Apply add is returning a new remove.")
	}
	return &effectValue, otherDownstreamArgs
}

func (crdt *TopKRmvCrdt) addOpHasIdInTop(elem, newElem TopKElement, oldTs int64) (effect Effect) {
	//Check if the "new elem" is > elem. If it is, add it. On the end, check if min should be updated.
	if newElem.isHigher(elem) {
		//fmt.Printf("[TOPK][ADD]Id already exists and new value is higher, number elems %d, max elems %d, min score %d\n", len(crdt.elems), crdt.maxElems, crdt.minTop.Score)
		effect = TopKReplaceEffect{newElem: newElem, oldElem: elem, oldMin: crdt.minTop, oldTs: oldTs}
		crdt.elems[newElem.Id] = newElem
		if elem.ReplicaID != newElem.ReplicaID { //Different replicas, so we'll keep the old entry in notInTop (as it might be relevant again depending on concurrent removes)
			//Given elem was in top, it has to go for sure to shadow.
			crdt.addToShadowTop(elem)
		}
		//Check if min should be updated
		if crdt.minTop.isEqual(elem) { //The old value was the smallest.
			crdt.findAndUpdateMin()
		}
		crdt.sortedElems = nil
	} else {
		//fmt.Printf("[TOPK][ADD]Id already exists but new value is lower, number elems %d, max elems %d, min score %d\n", len(crdt.elems), crdt.maxElems, crdt.minTop.Score)
		effect = TopKAddNotTopEffect{TopKAddEffect: TopKAddEffect{TopKElement: newElem, oldTs: oldTs}}
		//Need to check if >= smallestShadow or if the id already exists there. If yes, add there.
		//If not, goes to notInTop.
		if len(crdt.shadowTop) < crdt.maxShadowElems || newElem.isHigher(crdt.shadowMin) {
			crdt.addToShadowTop(newElem)
		} else if _, has := crdt.shadowTop[elem.Id]; has {
			crdt.addToShadowTop(newElem)
		} else {
			//Store in notInTop as it might be relevant later on
			crdt.addToNotInTop(newElem)
		}
	}
	return
}

func (crdt *TopKRmvCrdt) addOpNotHasIdInTop(newElem TopKElement, oldTs int64) (effect Effect) {
	//Check if it should belong to the TopK (i.e., there's space or its score is > min)
	if len(crdt.elems) < crdt.maxElems {
		//fmt.Printf("[TOPK][ADD]Still has space for more elements, number elems %d, max elems %d, min score %d\n", len(crdt.elems), crdt.maxElems, crdt.minTop.Score)
		crdt.elems[newElem.Id] = newElem
		//Check if min should be updated
		if newElem.isSmaller(crdt.minTop) {
			effect = TopKReplaceEffect{newElem: newElem, oldMin: crdt.minTop, oldTs: oldTs}
			crdt.minTop = newElem
		} else {
			effect = TopKAddEffect{TopKElement: newElem, oldTs: oldTs}
		}
		crdt.sortedElems = nil
	} else if newElem.isHigher(crdt.minTop) {
		//fmt.Printf("[TOPK][ADD]Doesn't have space for more elements, but new is higher than smallest score. Number elems %d, max elems %d, min score %d\n", len(crdt.elems), crdt.maxElems, crdt.minTop.Score)
		effect = TopKReplaceEffect{newElem: newElem, oldElem: crdt.minTop, oldMin: crdt.minTop, oldTs: oldTs}
		//Move min from top to shadowTop to give space for new elem with higher score.
		crdt.moveMinToShadowTop()
		crdt.elems[newElem.Id] = newElem
	} else {
		//Top is full and newElem < minTop. May need to add this to either shadowTop or notTop
		//fmt.Printf("[TOPK][ADD]Doesn't have space for more elements and new is smaller than smallest score. Number elems %d, max elems %d, min score %d\n", len(crdt.elems), crdt.maxElems, crdt.minTop.Score)
		effect = TopKAddNotTopEffect{TopKAddEffect: TopKAddEffect{TopKElement: newElem, oldTs: oldTs}}
		if len(crdt.shadowTop) < crdt.maxShadowElems || newElem.isHigher(crdt.shadowMin) {
			crdt.addToShadowTop(newElem)
		} else if _, has := crdt.shadowTop[newElem.Id]; has {
			crdt.addToShadowTop(newElem)
		} else {
			crdt.addToNotInTop(newElem)
		}
	}
	return
}

func (crdt *TopKRmvCrdt) moveMinToShadowTop() {
	crdt.addToShadowTop(crdt.minTop)
	delete(crdt.elems, crdt.minTop.Id)
	crdt.findAndUpdateMin()
	crdt.sortedElems = nil
}

func (crdt *TopKRmvCrdt) addToShadowTop(elem TopKElement) {
	entry, hasEntry := crdt.shadowTop[elem.Id]
	if !hasEntry {
		entry = make(setTopKElement)
		crdt.shadowTop[elem.Id] = entry
		crdt.moveShadowMinToNotTop(elem) //Also updates shadowMin
	} else if crdt.shadowMin.Id == elem.Id && elem.Score > crdt.shadowMin.Score {
		//Must update min (the smallest was this ID's previous score, but the new score is higher)
		crdt.findAndUpdateShadowMin()
	}
	entry.add(elem)
}

//Note: This also updates the shadowMin. Is there any situation wherre this is not necessary?
func (crdt *TopKRmvCrdt) moveShadowMinToNotTop(latestAdd TopKElement) {
	if len(crdt.shadowTop) <= crdt.maxShadowElems { //<= because we already added the new element but haven't moved the old min yet.
		//Still need to update min
		if latestAdd.isSmaller(crdt.shadowMin) { //latestAdd is smaller than the minimum
			crdt.shadowMin = latestAdd
		}
		return
	}
	oldMin := crdt.shadowTop[crdt.shadowMin.Id]
	entry, has := crdt.notInTop[crdt.shadowMin.Id]
	if !has {
		entry = oldMin
		crdt.notInTop[crdt.shadowMin.Id] = entry
	} else {
		entry.addAll(oldMin)
	}
	delete(crdt.shadowTop, crdt.shadowMin.Id)
	crdt.findAndUpdateShadowMin()
}

func (crdt *TopKRmvCrdt) addToNotInTop(elem TopKElement) {
	entry, hasEntry := crdt.notInTop[elem.Id]
	if !hasEntry {
		entry = make(setTopKElement)
		crdt.notInTop[elem.Id] = entry
	}
	entry.add(elem)
}

func (crdt *TopKRmvCrdt) applyRemoveAll(op *DownstreamTopKRemoveAll) (effect *Effect, otherDownstreamArgs DownstreamArguments) {
	//NOTE: This is a temporary fix, the correct size should be just len(op.DownRems). Check getTopKRemoveAllDownstreamArgs for details.
	downAdds := DownstreamTopKAddAll{DownstreamAdds: make([]TopKElement, (len(op.DownRems)+len(op.OptDownRems))*2)} //Some removes may generate 2 adds
	//downAdds := DownstreamTopKAddAll{DownstreamAdds: make([]TopKElement, len(op.DownRems))}
	nAdds, nEffects := 0, 0
	listEffect := TopKRemoveAllEffect{effects: make([]*TopKRemoveEffect, len(op.DownRems)+len(op.OptDownRems))} //When effects are updated I will likely need to change this

	//Need to apply the same algorithm for both downRems and optRems (if present)
	currRems := op.DownRems
	for i := 0; i < 2; i++ {
		for j, remID := range currRems {
			//Must be <= as the remove's clk is a copy without incrementing.
			remEffect := TopKRemoveEffect{id: remID, notTopRemoved: make(setTopKElement)}
			rems, hasRems := crdt.rems[remID]
			//Works for both when there's only 1 Vc and for when there's as many Vcs as downRems
			vc := op.Vc[j%len(op.Vc)]
			if !hasRems {
				remEffect.previousVc = nil
				crdt.rems[remID] = vc
			} else {
				remEffect.previousVc = rems.Copy()
				crdt.rems[remID] = rems.Merge(vc)
			}

			idShadow, firstDown := crdt.remOpRemoveFromNotTopAndShadow(remID, vc, remEffect)
			var secondDown DownstreamArguments

			//Remove from elems if the element's TS is lower.
			if elem, hasElem := crdt.elems[remID]; hasElem && elem.Ts <= vc.GetPos(elem.ReplicaID) {
				delete(crdt.elems, remID)
				remEffect.remElem, remEffect.oldMin = elem, crdt.minTop
				crdt.sortedElems = nil

				if len(crdt.elems) == crdt.maxElems-1 {
					remEffect.minAddedToTop, secondDown = crdt.remOpRemoveFromFullTop(elem)
				} else {
					crdt.remOpRemoveFromNonFullTop(idShadow, elem)
				}
			}
			listEffect.effects[nEffects] = &remEffect
			nEffects++
			if (firstDown != DownstreamTopKAdd{}) {
				downAdds.DownstreamAdds[nAdds] = firstDown.TopKElement
				nAdds++
			}
			if (secondDown != DownstreamTopKAdd{}) {
				downAdds.DownstreamAdds[nAdds] = secondDown.(DownstreamTopKAdd).TopKElement
				nAdds++
			}
		}
		currRems = op.OptDownRems
	}
	var effectI Effect = listEffect
	if nAdds == 0 {
		return &effectI, nil
	}
	downAdds.DownstreamAdds = downAdds.DownstreamAdds[0:nAdds]
	return &effectI, downAdds
}

/*
All remove effects are going to need:
- Previous VC (or nil, if there wasn't any)
- entries retired from notInTop
- need to know if the element was removed from top...?
Variants for element removed:
- Nothing happened;
- Only min was updated;
- TopK was full previously:
	- Was able to find an element to add, which is now the min;
	- Wasn't able to find an element to add and the removed one was the min;
	- Didn't find an element to add;
*/
func (crdt *TopKRmvCrdt) applyRemove(op *DownstreamTopKRemove) (effect *Effect, otherDownstreamArgs DownstreamArguments) {
	//Must be <= as the remove's clk is a copy without incrementing.
	remEffect := TopKRemoveEffect{id: op.Id, notTopRemoved: make(setTopKElement)}
	rems, hasRems := crdt.rems[op.Id]
	if !hasRems {
		remEffect.previousVc = nil
		crdt.rems[op.Id] = op.Vc
	} else {
		remEffect.previousVc = rems.Copy()
		crdt.rems[op.Id] = rems.Merge(op.Vc)
	}

	idShadow, firstDown := crdt.remOpRemoveFromNotTopAndShadow(op.Id, op.Vc, remEffect)

	//Remove from elems if the element's TS is lower.
	if elem, hasElem := crdt.elems[op.Id]; hasElem && elem.Ts <= op.Vc.GetPos(elem.ReplicaID) {
		delete(crdt.elems, op.Id)
		remEffect.remElem, remEffect.oldMin = elem, crdt.minTop
		crdt.sortedElems = nil

		if len(crdt.elems) == crdt.maxElems-1 {
			remEffect.minAddedToTop, otherDownstreamArgs = crdt.remOpRemoveFromFullTop(elem)
		} else {
			crdt.remOpRemoveFromNonFullTop(idShadow, elem)
		}
	}

	var eff Effect = remEffect
	if (firstDown != DownstreamTopKAdd{} && otherDownstreamArgs == nil) {
		return &eff, firstDown
	}
	if (firstDown != DownstreamTopKAdd{}) { //This implies otherDownstreamArgs != nil
		return &eff, DownstreamTopKAddAll{DownstreamAdds: []TopKElement{
			firstDown.TopKElement, otherDownstreamArgs.(DownstreamTopKAdd).TopKElement}}
	}
	return &eff, otherDownstreamArgs
}

func (crdt *TopKRmvCrdt) remOpRemoveFromNotTopAndShadow(id int32, vc clocksi.Timestamp,
	remEffect TopKRemoveEffect) (idShadow setTopKElement, otherDown DownstreamTopKAdd) {
	//Find all adds for id that are in idShadow/idNotTop whose ts is < clock[replicaID of the rmv] and remove them.
	//Note: if it exists in idShadow, it does not exist in idNotTop
	idShadow = crdt.shadowTop[id]
	for elem := range idShadow {
		if elem.Ts <= vc.GetPos(elem.ReplicaID) {
			delete(idShadow, elem)
			remEffect.notTopRemoved.add(elem) //Later will probably need to move this to idNotTop
		}
	}
	if idShadow != nil {
		_, otherDown = crdt.updateShadowTopAfterDelete(idShadow, id)
		return
	}

	idNotTop := crdt.notInTop[id]
	for elem := range idNotTop {
		if elem.Ts <= vc.GetPos(elem.ReplicaID) {
			delete(idNotTop, elem)
			remEffect.notTopRemoved.add(elem)
		}
	}
	//Id was totally removed
	if idNotTop != nil && len(idNotTop) == 0 {
		delete(crdt.notInTop, id)
	}

	return idShadow, DownstreamTopKAdd{}
}

func (crdt *TopKRmvCrdt) remOpRemoveFromFullTop(elemThatWasOnTop TopKElement) (minAddedToTop bool, otherDownstreamArgs DownstreamArguments) {
	//TopK was full previously, let's check in shadowTop
	//Note: We definitely do not need to promote from notInTop to top. (as, if so, it would already be in shadowTop)
	highestElem := crdt.getMaxShadowTop()
	if highestElem != makeEmptyTopKElement() { //Checking that it had elems
		//Promote to top-k and set as min
		crdt.elems[highestElem.Id] = highestElem
		crdt.minTop = highestElem
		//No otherDownstreamArgs (as shadowTop is already replicated)
		//Need to promote from notTop to shadowTop
		shadow := crdt.shadowTop[crdt.minTop.Id]
		delete(shadow, crdt.minTop)
		has, down := crdt.updateShadowTopAfterDelete(shadow, crdt.minTop.Id)
		if has {
			otherDownstreamArgs = down
		}
		minAddedToTop = true
	} else if elemThatWasOnTop.isEqual(crdt.minTop) {
		//No elem to add to top-k, however the removed element was the min. Need to find new one
		crdt.findAndUpdateMin()
	}
	return
}

func (crdt *TopKRmvCrdt) remOpRemoveFromNonFullTop(shadow setTopKElement, remElem TopKElement) {
	if len(shadow) > 0 {
		//Note: Given the top is not full, we know the entries for the removed element can only be in idShadow
		//As both idShadow and notInTop are empty other than to have repeated elements already in top.
		highest := makeEmptyTopKElement()
		for shadowElem := range shadow {
			if shadowElem.isHigher(highest) {
				highest = shadowElem
			}
		}
		delete(shadow, highest)
		if len(shadow) == 0 {
			delete(crdt.shadowTop, highest.Id)
		}
		crdt.elems[highest.Id] = highest
		if crdt.shadowMin == highest { //Need to find min
			crdt.findAndUpdateShadowMin()
		}
		if remElem.isEqual(crdt.minTop) {
			//If the removed elem was the min, the one we added now has, for sure, an even smaller value
			crdt.minTop = highest
		}
	} else if remElem.isEqual(crdt.minTop) {
		//Removed element was the min, need to find new min
		crdt.findAndUpdateMin()
	}
}

//Finds a min in notTop and promotes it to shadowTop, setting shadowMin
func (crdt *TopKRmvCrdt) updateShadowTopAfterDelete(shadow setTopKElement, id int32) (has bool, otherDown DownstreamTopKAdd) {
	if len(shadow) == 0 {
		delete(crdt.shadowTop, id)
	} else if len(crdt.notInTop) == 0 { //NotTop empty
		if len(crdt.shadowTop) == 1 { //Need to update min
			crdt.shadowMin = makeEmptyTopKElement()
			for elem := range shadow {
				if elem.isHigher(crdt.shadowMin) {
					crdt.shadowMin = elem
				}
			}
		}
		return false, DownstreamTopKAdd{}
	} else { //There are elements in notTop.
		//We may need to send what's left to the notTop. Sigh
		isOK := false
		for elem := range shadow {
			if !crdt.shadowMin.isHigher(elem) {
				isOK = true
			}
		}
		//if isOK == true, we don't need to get anything from notTop
		if isOK {
			return false, DownstreamTopKAdd{}
		} else {
			//Move this to notTop.
			entry, has := crdt.notInTop[id]
			if !has {
				crdt.notInTop[id] = crdt.shadowTop[crdt.shadowMin.Id]
			} else {
				entry.addAll(crdt.shadowTop[crdt.shadowMin.Id])
			}
			delete(crdt.shadowTop, id)
		}
	}
	//Need to promote entry from notTop
	highestElem := crdt.getMaxNotTop()
	if highestElem == makeEmptyTopKElement() {
		if len(crdt.shadowTop) == 0 {
			crdt.shadowMin = makeEmptyTopKElement()
		}
		return false, DownstreamTopKAdd{} //No promotion as there was nothing in notTop
	}
	crdt.shadowTop[highestElem.Id] = crdt.notInTop[highestElem.Id]
	delete(crdt.notInTop, highestElem.Id)
	crdt.shadowMin = highestElem
	otherDown = DownstreamTopKAdd{TopKElement: highestElem}
	if otherDown.Data == nil {
		otherDown.Data = &[]byte{}
	}
	return true, otherDown
}

//Called whenever the min needs to be updated, due to either an add or a remove
func (crdt *TopKRmvCrdt) findAndUpdateMin() {
	minSoFar := makeEmptyTopKElement()
	for _, elem := range crdt.elems {
		if elem.isSmaller(minSoFar) {
			minSoFar = elem
		}
	}
	crdt.minTop = minSoFar
}

//Called whenever the shadow min needs to be updated, due to either an add or remove from the shadow map
func (crdt *TopKRmvCrdt) findAndUpdateShadowMin() {
	minSoFar := makeEmptyTopKElement()
	for _, elemSet := range crdt.shadowTop {
		for elem := range elemSet {
			if elem.isSmaller(minSoFar) {
				minSoFar = elem
			}
		}
	}
	crdt.shadowMin = minSoFar
}

func (crdt *TopKRmvCrdt) getMaxShadowTop() (max TopKElement) {
	max = makeEmptyTopKElement()
	for id, setElems := range crdt.shadowTop {
		if _, has := crdt.elems[id]; !has {
			//We're only interested in IDs not already in shadowTop
			for shadowElem := range setElems {
				if shadowElem.isHigher(max) {
					max = shadowElem
				}
			}
		}
	}
	return
}

func (crdt *TopKRmvCrdt) getMaxNotTop() (max TopKElement) {
	max = makeEmptyTopKElement()
	for _, setElems := range crdt.notInTop {
		//Note: There is no overlap of IDs between shadowTop and notTop
		for elemNotTop := range setElems {
			if elemNotTop.isHigher(max) {
				max = elemNotTop
			}
		}
	}
	return
}

func (crdt *TopKRmvCrdt) IsOperationWellTyped(args UpdateArguments) (ok bool, err error) {
	return true, nil
}

//METHODS FOR INVERSIBLE CRDT

func (crdt *TopKRmvCrdt) Copy() (copyCRDT InversibleCRDT) {
	newCrdt := TopKRmvCrdt{
		genericInversibleCRDT: crdt.genericInversibleCRDT.copy(),
		vc:                    crdt.vc.Copy(),
		replicaID:             crdt.replicaID,
		maxElems:              crdt.maxElems,
		minTop:                crdt.minTop,
		elems:                 make(map[int32]TopKElement),
		rems:                  make(map[int32]clocksi.Timestamp),
		notInTop:              make(map[int32]setTopKElement),
	}

	for id, elem := range crdt.elems {
		newCrdt.elems[id] = elem
	}
	for id, clk := range crdt.rems {
		newCrdt.rems[id] = clk.Copy()
	}
	for id, set := range crdt.notInTop {
		newCrdt.notInTop[id] = set.copy()
	}

	return &newCrdt
}

func (crdt *TopKRmvCrdt) RebuildCRDTToVersion(targetTs clocksi.Timestamp) {
	crdt.genericInversibleCRDT.rebuildCRDTToVersion(targetTs, crdt.undoEffect, crdt.reapplyOp, crdt.notifyRebuiltComplete)
}

func (crdt *TopKRmvCrdt) reapplyOp(updArgs DownstreamArguments) (effect *Effect) {
	effect, _ = crdt.applyDownstream(updArgs)
	return
}

func (crdt *TopKRmvCrdt) undoEffect(effect *Effect) {
	switch typedEffect := (*effect).(type) {
	case TopKAddEffect:
		crdt.undoAddEffect(&typedEffect)
	case TopKAddNotTopEffect:
		crdt.undoAddNotTopEffect(&typedEffect)
	case TopKReplaceEffect:
		crdt.undoReplaceEffect(&typedEffect)
	case TopKRemoveEffect:
		crdt.undoRemoveEffect(&typedEffect)
	case TopKAddAllEffect:
		crdt.undoAddAllEffect(&typedEffect)
	case TopKRemoveAllEffect:
		crdt.undoRemoveAllEffect(&typedEffect)
	}
}

func (crdt *TopKRmvCrdt) undoAddEffect(effect *TopKAddEffect) {
	crdt.vc.UpdateForcedPos(effect.ReplicaID, effect.oldTs)
	//Element was added to top and there wasn't any entry for it previously on top
	delete(crdt.elems, effect.Id)
	//Both effects will need the old Ts.
	/*
		Possible cases:
		- Add is there but with higher value. In this case, it only removes entry from notInTop
		- Add is there with this value. In this case we would need to search for the higher value (would be better to store it in the effect). And possibly it might disapear from top...
		- Add isn't there but it is in notInTop. Remove it from there and nothing else changes
		I also need the old ts...
	*/
}

func (crdt *TopKRmvCrdt) undoAddNotTopEffect(effect *TopKAddNotTopEffect) {
	crdt.vc.UpdateForcedPos(effect.ReplicaID, effect.oldTs)
	//Element was added to notInTop
	notInTop := crdt.notInTop[effect.Id]
	delete(notInTop, effect.TopKElement)
	if len(notInTop) == 0 {
		delete(crdt.notInTop, effect.Id)
	}
}

func (crdt *TopKRmvCrdt) undoReplaceEffect(effect *TopKReplaceEffect) {
	crdt.vc.UpdateForcedPos(effect.newElem.ReplicaID, effect.oldTs)
	//New element was added to the top
	delete(crdt.elems, effect.newElem.Id)
	//If there was an old element, it could had been in the top or notInTop. Regardless, it now belongs to the top
	if (!effect.oldElem.isEqual(TopKElement{})) {
		crdt.elems[effect.oldElem.Id] = effect.oldElem
		//If the old element was in notInTop, remove it from there
		if notInTop, has := crdt.notInTop[effect.oldElem.Id]; has {
			delete(notInTop, effect.oldElem)
			if len(notInTop) == 0 {
				delete(crdt.notInTop, effect.oldElem.Id)
			}
		}
	}
	//Update the min
	crdt.minTop = effect.oldMin
}

/*
All remove effects are going to need:
- Previous VC (or nil, if there wasn't any)
- entries retired from notInTop
- need to know if the element was removed from top...?
Variants for element removed:
- Nothing happened;
- Only min was updated;
- TopK was full previously:
	- Was able to find an element to add, which is now the min;
	- Wasn't able to find an element to add and the removed one was the min;
	- Didn't find an element to add;
*/
func (crdt *TopKRmvCrdt) undoRemoveEffect(effect *TopKRemoveEffect) {
	if effect.previousVc == nil {
		//There was no remove previous to this one
		delete(crdt.rems, effect.id)
	} else {
		crdt.rems[effect.id] = effect.previousVc.Copy()
	}

	notTop, has := crdt.notInTop[effect.id]
	if !has {
		notTop = make(setTopKElement)
		crdt.notInTop[effect.id] = notTop
	}
	//Add elements removed from notInTop
	for elem := range effect.notTopRemoved {
		notTop.add(elem)
	}

	if (!effect.remElem.isEqual(TopKElement{})) {
		//An element was removed.
		//When this remove was executed, it's possible that a concurrent add in notInTop for the same elem was promoted to the top
		inTop, has := crdt.elems[effect.remElem.Id]
		if has {
			//Move that element to notInTop
			notTop, has = crdt.notInTop[effect.id]
			if !has {
				notTop = make(setTopKElement)
				crdt.notInTop[effect.id] = notTop
			}
			notTop.add(inTop)
		}
		//Add removed element back to the top
		crdt.elems[effect.id] = effect.remElem
		if effect.minAddedToTop {
			//When the remove was executed, the actual min was promoted from notInTop to top. Now, we'll demote it back to notInTop
			delete(crdt.elems, crdt.minTop.Id)
			notTop, has = crdt.notInTop[crdt.minTop.Id]
			if !has {
				notTop = make(setTopKElement)
				crdt.notInTop[crdt.minTop.Id] = notTop
			}
			notTop.add(crdt.minTop)
		}
		//Update the min
		crdt.minTop = effect.oldMin
	}
}

func (crdt *TopKRmvCrdt) undoAddAllEffect(effect *TopKAddAllEffect) {
	for _, eff := range effect.effects {
		crdt.undoEffect(eff)
	}
}

func (crdt *TopKRmvCrdt) undoRemoveAllEffect(effect *TopKRemoveAllEffect) {
	for _, eff := range effect.effects {
		crdt.undoRemoveEffect(eff)
	}
}

func (crdt *TopKRmvCrdt) notifyRebuiltComplete(currTs *clocksi.Timestamp) {}

/*
func (crdt *TopKRmvCrdt) applyRemove(op *DownstreamTopKRemove) (effect *Effect, otherDownstreamArgs DownstreamArguments) {
	remEffect := TopKRemoveEffect{id: op.Id, notTopRemoved: make(setTopKElement), oldMin: crdt.minTop}
	rems, hasRems := crdt.rems[op.Id]
	if !hasRems {
		crdt.rems[op.Id] = op.Vc
	} else {
		remEffect.previousVc = rems.Copy()
		crdt.rems[op.Id] = rems.Merge(op.Vc)
	}
	//Find all adds for op.Id that are in notInTop whose ts is < clock[replicaID of the rmv] and remove them.
	hiddenForId := crdt.notInTop[op.Id]
	for elem := range hiddenForId {
		if elem.Ts < op.Vc.GetPos(elem.ReplicaID) {
			delete(hiddenForId, elem)
			remEffect.notTopRemoved.add(elem)
		}
	}
	//Id was totally removed
	if hiddenForId != nil && len(hiddenForId) == 0 {
		delete(crdt.notInTop, op.Id)
	}
	//Also remove from elems if the same condition is true.
	if elem, hasElem := crdt.elems[op.Id]; hasElem && elem.Ts < op.Vc.GetPos(elem.ReplicaID) {
		delete(crdt.elems, op.Id)
		remEffect.remElem = elem
		if len(crdt.elems) == crdt.maxElems-1 {
			//Top-k was full previously, need to find the next highest value to replace (possibly in different ID)
			highestElem := TopKElement{}
			for id, setElems := range crdt.notInTop {
				if _, has := crdt.elems[id]; !has {
					//We're only interested in IDs which aren't already in the top-k
					for elemNotTop := range setElems {
						if elemNotTop.isHigher(highestElem) {
							highestElem = elemNotTop
						}
					}
				}
			}
			//Check that notInTop actually had elements.
			if (highestElem != TopKElement{}) {
				//Promote to top-k and set as min
				crdt.elems[highestElem.Id] = highestElem
				crdt.minTop = highestElem
				otherDownstreamArgs = DownstreamTopKAdd{TopKElement: highestElem}
				remEffect.minAddedToTop = true
			} else if elem == crdt.minTop {
				//No elem to add to top-k, however the removed element was the min. Need to find new one
				crdt.findAndUpdateMin()
			}
		} else if elem == crdt.minTop {
			//Removed element was the min, need to find new min
			crdt.findAndUpdateMin()
		}
	}
	var eff Effect = remEffect
	return &eff, otherDownstreamArgs
}
*/

//Protobuf functions
func (crdtOp TopKInit) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	init := protobuf.GetTopkinitop()
	crdtOp.TopSize, crdtOp.ShadowTopSize = init.GetTopSize(), init.GetShadowTopSize()
	return crdtOp
}

func (crdtOp TopKInit) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Topkinitop: &proto.ApbTopKInit{
		TopSize: &crdtOp.TopSize, ShadowTopSize: &crdtOp.ShadowTopSize}}
}

func (crdtOp TopKAdd) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	add := protobuf.GetTopkrmvop().GetAdds()[0]
	crdtOp.TopKScore = TopKScore{Id: add.GetPlayerId(), Score: add.GetScore(), Data: &add.Data}
	//fmt.Println("[TopK][FromUpdateObject]Pair:", *add.PlayerId, " ", *add.Score)
	return crdtOp
}

func (crdtOp TopKAdd) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	add := proto.ApbIntPair{PlayerId: pb.Int32(crdtOp.Id), Score: pb.Int32(crdtOp.Score)}
	//fmt.Println("[TopK][ToUpdateObject]Pair:", *add.PlayerId, " ", *add.Score)
	if crdtOp.Data != nil {
		add.Data = *crdtOp.Data
	}
	return &proto.ApbUpdateOperation{Topkrmvop: &proto.ApbTopkRmvUpdate{Adds: []*proto.ApbIntPair{&add}}}
}

func (crdtOp TopKRemove) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	crdtOp.Id = protobuf.GetTopkrmvop().GetRems()[0]
	return crdtOp
}

func (crdtOp TopKRemove) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Topkrmvop: &proto.ApbTopkRmvUpdate{Rems: []int32{crdtOp.Id}}}
}

func (crdtOp TopKAddAll) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	adds := protobuf.GetTopkrmvop().GetAdds()
	crdtOp.Scores = make([]TopKScore, len(adds))
	for i, add := range adds {
		crdtOp.Scores[i] = TopKScore{Id: add.GetPlayerId(), Score: add.GetScore(), Data: &add.Data}
	}
	return crdtOp
}

func (crdtOp TopKAddAll) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	protoAdds := make([]*proto.ApbIntPair, len(crdtOp.Scores))
	for i, score := range crdtOp.Scores {
		add := proto.ApbIntPair{PlayerId: pb.Int32(score.Id), Score: pb.Int32(score.Score)}
		if score.Data != nil {
			add.Data = *score.Data
		}
		protoAdds[i] = &add
	}
	return &proto.ApbUpdateOperation{Topkrmvop: &proto.ApbTopkRmvUpdate{Adds: protoAdds}}
}

func (crdtOp TopKRemoveAll) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	crdtOp.Ids = protobuf.GetTopkrmvop().GetRems()
	return crdtOp
}

func (crdtOp TopKRemoveAll) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Topkrmvop: &proto.ApbTopkRmvUpdate{Rems: crdtOp.Ids}}
}

func (crdtState TopKValueState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	protoScores := protobuf.GetTopk().GetValues()
	if protoScores == nil {
		//Partial read
		protoScores = protobuf.GetPartread().GetTopk().GetPairs().GetValues()
	}
	crdtState.Scores = make([]TopKScore, len(protoScores))
	for i, pair := range protoScores {
		data := pair.GetData()
		crdtState.Scores[i] = TopKScore{Id: pair.GetPlayerId(), Score: pair.GetScore(), Data: &data}
	}
	return crdtState
}

func (crdtState TopKValueState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	protos := make([]*proto.ApbIntPair, len(crdtState.Scores))
	for i, score := range crdtState.Scores {
		protos[i] = &proto.ApbIntPair{PlayerId: pb.Int32(score.Id), Score: pb.Int32(score.Score), Data: *score.Data}
	}
	return &proto.ApbReadObjectResp{Topk: &proto.ApbGetTopkResp{Values: protos}}
}

func (args GetTopNArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	args.NumberEntries = protobuf.GetTopk().GetGetn().GetAmount()
	return args
}

func (args GetTopKAboveValueArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	args.MinValue = protobuf.GetTopk().GetGetabovevalue().GetMinValue()
	return args
}

func (args GetTopNArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	return &proto.ApbPartialReadArgs{Topk: &proto.ApbTopkPartialRead{Getn: &proto.ApbTopkGetNRead{
		Amount: pb.Int32(args.NumberEntries),
	}}}
}

func (args GetTopKAboveValueArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	return &proto.ApbPartialReadArgs{Topk: &proto.ApbTopkPartialRead{Getabovevalue: &proto.ApbTopkAboveValueRead{
		MinValue: pb.Int32(args.MinValue),
	}}}
}

func (crdtOp TopKInit) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	init := protobuf.GetTopkinitOp()
	crdtOp.TopSize, crdtOp.ShadowTopSize = init.GetTopSize(), init.GetShadowTopSize()
	return crdtOp
}

func (crdtOp TopKInit) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	return &proto.ProtoOpDownstream{TopkinitOp: &proto.ProtoTopKInitDownstream{
		TopSize: &crdtOp.TopSize, ShadowTopSize: &crdtOp.ShadowTopSize}}
}

func (downOp DownstreamTopKAdd) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	addProto := protobuf.GetTopkrmvOp().GetAdds()[0]
	downOp.Id, downOp.Score, downOp.Ts, downOp.ReplicaID, downOp.Data = addProto.GetId(), addProto.GetScore(), addProto.GetTs(),
		int16(addProto.GetReplicaID()), &addProto.Data
	return downOp
}

func (downOp DownstreamTopKRemove) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	//remProto := protobuf.GetTopkrmvOp().GetRems()[0]
	//downOp.Id, downOp.Vc = remProto.GetId(), clocksi.ClockSiTimestamp{}.FromBytes(remProto.GetVc())
	remProto := protobuf.GetTopkrmvOp().GetRems()
	downOp.Id, downOp.Vc = remProto.GetIds()[0], clocksi.ClockSiTimestamp{}.FromBytes(remProto.GetVcs()[0])
	return downOp
}

func (downOp DownstreamTopKAdd) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	return &proto.ProtoOpDownstream{TopkrmvOp: &proto.ProtoTopKRmvDownstream{Adds: []*proto.ProtoTopKElement{&proto.ProtoTopKElement{
		Id: pb.Int32(downOp.Id), Score: pb.Int32(downOp.Score), Ts: pb.Int64(downOp.Ts),
		ReplicaID: pb.Int32(int32(downOp.ReplicaID)), Data: *downOp.Data,
	}}}}
}

func (downOp DownstreamTopKRemove) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	//return &proto.ProtoOpDownstream{TopkrmvOp: &proto.ProtoTopKRmvDownstream{Rems: []*proto.ProtoTopKIdVc{&proto.ProtoTopKIdVc{
	//Id: pb.Int32(downOp.Id), Vc: downOp.Vc.ToBytes(),
	//}}}}
	return &proto.ProtoOpDownstream{TopkrmvOp: &proto.ProtoTopKRmvDownstream{Rems: &proto.ProtoTopKRmvRemove{
		Ids: []int32{downOp.Id}, Vcs: [][]byte{downOp.Vc.ToBytes()}}}}
}

func (downOp DownstreamTopKAddAll) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	addProto := protobuf.GetTopkrmvOp().GetAdds()
	downOp.DownstreamAdds = make([]TopKElement, len(addProto))
	for i, add := range addProto {
		downOp.DownstreamAdds[i] = TopKElement{Id: add.GetId(), Score: add.GetScore(), Ts: add.GetTs(), ReplicaID: int16(add.GetReplicaID()), Data: &add.Data}
	}
	return downOp
}

func (downOp DownstreamTopKRemoveAll) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	remProto := protobuf.GetTopkrmvOp().GetRems()
	ids, vcs := remProto.GetIds(), remProto.GetVcs()
	downOp.DownRems = ids
	downOp.Vc = make([]clocksi.Timestamp, len(vcs))
	for i, vc := range vcs {
		downOp.Vc[i] = clocksi.ClockSiTimestamp{}.FromBytes(vc)
	}
	return downOp
}

func (downOp DownstreamTopKAddAll) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	protoElems := make([]*proto.ProtoTopKElement, len(downOp.DownstreamAdds))
	for i, add := range downOp.DownstreamAdds {
		protoElems[i] = &proto.ProtoTopKElement{Id: pb.Int32(add.Id), Score: pb.Int32(add.Score), Ts: pb.Int64(add.Ts),
			ReplicaID: pb.Int32(int32(add.ReplicaID)), Data: *add.Data}
	}
	return &proto.ProtoOpDownstream{TopkrmvOp: &proto.ProtoTopKRmvDownstream{Adds: protoElems}}
}

func (downOp DownstreamTopKRemoveAll) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	protoVcs := make([][]byte, len(downOp.Vc))
	for i, vc := range downOp.Vc {
		protoVcs[i] = vc.ToBytes()
	}
	return &proto.ProtoOpDownstream{TopkrmvOp: &proto.ProtoTopKRmvDownstream{Rems: &proto.ProtoTopKRmvRemove{
		Ids: downOp.DownRems, Vcs: protoVcs}}}
}

func (crdt *TopKRmvCrdt) ToProtoState() (protobuf *proto.ProtoState) {
	protoElems, protoRems := make([]*proto.ProtoTopKElement, len(crdt.elems)),
		make([]*proto.ProtoTopKIdVc, len(crdt.rems))
	i, j, k := 0, 0, 0

	for _, elem := range crdt.elems {
		protoElems[i] = &proto.ProtoTopKElement{Id: &elem.Id, Score: &elem.Score,
			Ts: &elem.Ts, ReplicaID: pb.Int32(int32(elem.ReplicaID)), Data: *elem.Data}
		i++
	}
	for playerId, vc := range crdt.rems {
		protoRems[j] = &proto.ProtoTopKIdVc{Id: &playerId, Vc: vc.ToBytes()}
		j++
	}
	nElemsNotTop := 0
	for _, elems := range crdt.notInTop {
		nElemsNotTop += len(elems)
	}
	protoNotTop := make([]*proto.ProtoTopKElement, nElemsNotTop)
	for _, elems := range crdt.notInTop {
		for elem := range elems {
			protoNotTop[k] = &proto.ProtoTopKElement{Id: &elem.Id, Score: &elem.Score,
				Ts: &elem.Ts, ReplicaID: pb.Int32(int32(elem.ReplicaID)), Data: *elem.Data}
			k++
		}
	}
	smallest := &proto.ProtoTopKElement{Id: &crdt.minTop.Id, Score: &crdt.minTop.Score,
		Ts: &crdt.minTop.Ts, ReplicaID: pb.Int32(int32(crdt.minTop.ReplicaID)), Data: *crdt.minTop.Data}
	return &proto.ProtoState{Topk: &proto.ProtoTopKState{Elems: protoElems, Rems: protoRems,
		NotTop: protoNotTop, Smallest: smallest, MaxElems: pb.Int32(int32(crdt.maxElems)), Vc: crdt.vc.ToBytes()}}
}

func (crdt *TopKRmvCrdt) FromProtoState(proto *proto.ProtoState, ts *clocksi.Timestamp, replicaID int16) (newCRDT CRDT) {
	topKProto := proto.GetTopk()
	elems, rems, notTop := make(map[int32]TopKElement), make(map[int32]clocksi.Timestamp), make(map[int32]setTopKElement)

	for _, protoElem := range topKProto.GetElems() {
		data := protoElem.GetData()
		elems[protoElem.GetId()] = TopKElement{Id: protoElem.GetId(), Score: protoElem.GetScore(), Ts: protoElem.GetTs(),
			ReplicaID: int16(protoElem.GetReplicaID()), Data: &data}
	}
	for _, protoRem := range topKProto.GetRems() {
		rems[protoRem.GetId()] = clocksi.ClockSiTimestamp{}.FromBytes(protoRem.GetVc())
	}
	previousId := int32(math.MinInt32)
	var currElemSet setTopKElement
	for _, protoElem := range topKProto.GetNotTop() {
		//data := protoElem.GetData()
		if protoElem.GetId() != previousId {
			currElemSet = make(setTopKElement)
			previousId = protoElem.GetId()
			notTop[previousId] = currElemSet
		}
		data := protoElem.GetData()
		currElemSet.add(TopKElement{Id: protoElem.GetId(), Score: protoElem.GetScore(), Ts: protoElem.GetTs(),
			ReplicaID: int16(protoElem.GetReplicaID()), Data: &data})
	}
	smallestProto := topKProto.GetSmallest()
	smallestData := smallestProto.GetData()
	minTop := TopKElement{Id: smallestProto.GetId(), Score: smallestProto.GetScore(), Ts: smallestProto.GetTs(),
		ReplicaID: int16(smallestProto.GetReplicaID()), Data: &smallestData}
	vc := clocksi.ClockSiTimestamp{}.FromBytes(topKProto.GetVc())

	return (&TopKRmvCrdt{elems: elems, rems: rems, notInTop: notTop, minTop: minTop,
		maxElems: int(topKProto.GetMaxElems()), vc: vc}).initializeFromSnapshot(ts, replicaID)
}
