package crdt

import (
	"clocksi"
	"fmt"
	"strings"
)

/*TODO: Bug that affects potencially all CRDTs: in multi-update transactions, each update doesn't
reflect the effects of the previous upds, which can lead to wrong results.
E.g: in a set with uniques, add(a) -> rem(a) in the same transaction leads to wrong result - the
unique generated by add(a) won't be removed by rem(a).
*/

//Note: This CRDT is optimized for adds - this assumes that removes are a rarity.
//TODO: Undos
//TODO: Re-enable marks?

const (
	CRDTType_RRMAP              CRDTType = 11
	REDO                                 = true
	NORMAL                               = false
	INITIAL_UPDSNOTAPPLIED_SIZE          = 10 //Buffer size for updsnotapplied of each embedded CRDT
)

type RWEmbMapCrdt struct {
	*genericInversibleCRDT
	//entries RWEmbCRDT
	entries   map[string]CRDT
	removes   map[string]map[int64]*markedTimestamp //replicaID -> (clk value, mark)
	rmvClock  clocksi.Timestamp
	replicaID int64 //Needed for some embedded CRDTs and for rmvClock
	//Extra metadata for rebuilding old CRDT versions via inversibleCRDT.
	//Should not be copied or transmitted to other replicas
	keysToRebuild map[string]struct{} //Stores the keys of the CRDTs that were changed while going back in time
}

type markedTimestamp struct {
	ts   int64
	mark bool
}

/*
Idea: check archive article but opt OR-Set. But the idea is that a remove increases rmvClock
and sends replicaID's clk. On add, all pairs (replicaID, clk) are sent and an add only is
successful if removes gets emptied.
*/

/*
type RWEmbCRDT struct {
	CRDT
	//ReplicaID -> clock value
	clk map[int64]int64
}
*/

//States returned by queries

type EmbMapEntryState struct {
	States map[string]State
}

type EmbMapGetValueState struct {
	State State
}

type EmbMapHasKeyState struct {
	HasKey bool
}

type EmbMapKeysState struct {
	Keys []string
}

//Also uses queries defined in orMap.go
type EmbMapGetValueArguments struct {
	Key  string
	Args ReadArguments
}

type EmbMapPartialArguments struct {
	Args map[string]ReadArguments
}

//Operations

type EmbMapUpdate struct {
	Key string
	Upd UpdateArguments
}

//TODO: Might be worth it to change this to support multiple updates per key
type EmbMapUpdateAll struct {
	Upds map[string]UpdateArguments
}

//Removes are the same as the ones used in orMap

//Downstream operations

type DownstreamRWEmbMapUpdateAll struct {
	Upds       map[string]DownstreamArguments
	RmvEntries map[int64]int64 //replicaID -> clk value
	ReplicaID  int64
}

type DownstreamRWEmbMapRemoveAll struct {
	Rems      []string
	Ts        int64
	ReplicaID int64
}

//Operation effects for inversibleCRDT

//Add if mark was there or not for the replica. Also need to add the replicaID.
type RWEmbMapUpdateAllEffect struct {
	Updated        []string //Keys for which updates were applied
	ReplicaID      int64
	AddedMark      map[string]struct{}
	PreviousRmvClk map[string]map[int64]*markedTimestamp
}

//Can use previousClk to know if an entry was added to RmvEntries (if previousClk == 0, then a new entry was added)
type RWEmbMapRemoveAllEffect struct {
	RemovedCRDTs map[string]CRDT
	ReplicaID    int64
	PreviousClk  int64 //Previous value of rmvClock[replicaID]
}

//Upds
func (args EmbMapUpdate) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapUpdateAll) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args DownstreamRWEmbMapUpdateAll) MustReplicate() bool { return true }

func (args DownstreamRWEmbMapRemoveAll) MustReplicate() bool { return true }

//Downstreams
func (args DownstreamRWEmbMapUpdateAll) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args DownstreamRWEmbMapRemoveAll) GetCRDTType() CRDTType { return CRDTType_RRMAP }

//States
func (args EmbMapEntryState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapGetValueState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapGetValueState) GetREADType() READType { return READType_GET_VALUE }

func (args EmbMapHasKeyState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapHasKeyState) GetREADType() READType { return READType_HAS_KEY }

func (args EmbMapKeysState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapKeysState) GetREADType() READType { return READType_GET_KEYS }

//Note: crdt can (and most often will be) nil
func (crdt *RWEmbMapCrdt) Initialize(startTs *clocksi.Timestamp, replicaID int64) (newCrdt CRDT) {
	crdt = &RWEmbMapCrdt{
		genericInversibleCRDT: (&genericInversibleCRDT{}).initialize(startTs),
		entries:               make(map[string]CRDT),
		removes:               make(map[string]map[int64]*markedTimestamp),
		rmvClock:              clocksi.NewClockSiTimestamp(replicaID),
		replicaID:             replicaID,
	}
	newCrdt = crdt
	return
}

func (crdt *RWEmbMapCrdt) Read(args ReadArguments, updsNotYetApplied []*UpdateArguments) (state State) {
	switch typedArg := args.(type) {
	case StateReadArguments:
		return crdt.getState(updsNotYetApplied)
	case GetKeysArguments:
		return crdt.getKeys(updsNotYetApplied)
	case EmbMapGetValueArguments:
		return crdt.getValue(updsNotYetApplied, typedArg.Key, typedArg.Args)
	case HasKeyArguments:
		return crdt.hasKey(updsNotYetApplied, typedArg.Key)
	case EmbMapPartialArguments:
		return crdt.getPartialState(updsNotYetApplied, typedArg.Args)
	}
	return nil
}

func (crdt *RWEmbMapCrdt) getState(updsNotYetApplied []*UpdateArguments) (state EmbMapEntryState) {
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			states[key] = embCrdt.Read(StateReadArguments{}, updsNotYetApplied)
		}
		return EmbMapEntryState{States: states}
	}

	/*
		Each entry may contain either:
		A) multiple updates, at most one for each CRDT;
		B) multiple removes
		Since we have multiple entries, we may also have multiple updates for a CRDT.
		Including possibly a remove in the middle of a CRDT that later gets updated...

		So, idea:
		Have a map of key -> [Updates].
		Stores updates normally.
		Use NoOp{} to signal removes (and hide all ops before).
	*/

	applyByCRDT := make(map[string][]*UpdateArguments)
	var noOp UpdateArguments = NoOp{}
	for _, upds := range updsNotYetApplied {
		switch convUpds := (*upds).(type) {
		case EmbMapUpdate:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			applyByCRDT[convUpds.Key] = append(entry, &convUpds.Upd)
		case EmbMapUpdateAll:
			for key, upd := range convUpds.Upds {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				applyByCRDT[key] = append(entry, &upd)
			}
		case MapRemove:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
			applyByCRDT[convUpds.Key] = append(entry, &noOp)
		case MapRemoveAll:
			for _, key := range convUpds.Keys {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
				applyByCRDT[key] = append(entry, &noOp)
			}
		}
	}

	//Now, apply
	for key, upds := range applyByCRDT {
		if (*upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				states[key] = InitializeCrdt((*upds[1]).GetCRDTType(),
					crdt.replicaID).Read(StateReadArguments{}, upds[1:])
			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (*upds[0]))
			states[key] = embCrdt.Read(StateReadArguments{}, upds)
		}
	}

	//Also need to include CRDTs that aren't referred in applyByCRDT
	for key, embCrdt := range crdt.entries {
		if _, has := applyByCRDT[key]; !has {
			states[key] = embCrdt.Read(StateReadArguments{}, []*UpdateArguments{})
		}
	}
	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getPartialState(updsNotYetApplied []*UpdateArguments, args map[string]ReadArguments) (state EmbMapEntryState) {
	//Very similar to getState

	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, arg := range args {
			if embCrdt, has := crdt.entries[key]; has {
				states[key] = embCrdt.Read(arg, updsNotYetApplied)
			}
		}
		return EmbMapEntryState{States: states}
	}

	/*
		Each entry may contain either:
		A) multiple updates, at most one for each CRDT;
		B) multiple removes
		Since we have multiple entries, we may also have multiple updates for a CRDT.
		Including possibly a remove in the middle of a CRDT that later gets updated...

		So, idea:
		Have a map of key -> [Updates].
		Stores updates normally.
		Use NoOp{} to signal removes (and hide all ops before).
	*/

	applyByCRDT := make(map[string][]*UpdateArguments)
	var noOp UpdateArguments = NoOp{}
	for _, upds := range updsNotYetApplied {
		switch convUpds := (*upds).(type) {
		case EmbMapUpdate:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			applyByCRDT[convUpds.Key] = append(entry, &convUpds.Upd)
		case EmbMapUpdateAll:
			for key, upd := range convUpds.Upds {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				applyByCRDT[key] = append(entry, &upd)
			}
		case MapRemove:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
			applyByCRDT[convUpds.Key] = append(entry, &noOp)
		case MapRemoveAll:
			for _, key := range convUpds.Keys {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
				applyByCRDT[key] = append(entry, &noOp)
			}
		}
	}

	for key, arg := range args {
		if upds, has := applyByCRDT[key]; has {
			if (*upds[0] == NoOp{}) {
				if len(upds) > 1 {
					//Start from scratch
					states[key] = InitializeCrdt((*upds[1]).GetCRDTType(),
						crdt.replicaID).Read(StateReadArguments{}, upds[1:])
				} else {
					//Removed CRDT, thus doesn't belong to state
					continue
				}
			} else {
				embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (*upds[0]))
				states[key] = embCrdt.Read(StateReadArguments{}, upds)
			}
		} else if embCrdt, has := crdt.entries[key]; has {
			states[key] = embCrdt.Read(arg, []*UpdateArguments{})
		}
	}

	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getKeys(updsNotYetApplied []*UpdateArguments) (state MapKeysState) {
	//Literally a copy from ORMap. Sigh
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		keys := make([]string, len(crdt.entries))
		i := 0
		for key, _ := range crdt.entries {
			keys[i] = key
			i++
		}
		return MapKeysState{Keys: keys}
	}

	adds := make(map[string]struct{})
	rems := make(map[string]struct{})

	//Key idea: for each key, the latest update is the only one that matters, hence start at the end.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := (*updsNotYetApplied[i]).(type) {
		case EmbMapUpdate:
			if _, has := rems[typedUpd.Key]; !has {
				adds[typedUpd.Key] = struct{}{}
			}
		case MapRemove:
			if _, has := adds[typedUpd.Key]; !has {
				rems[typedUpd.Key] = struct{}{}
			}
		case EmbMapUpdateAll:
			for key, _ := range typedUpd.Upds {
				if _, has := rems[key]; !has {
					adds[key] = struct{}{}
				}
			}
		case MapRemoveAll:
			for _, key := range typedUpd.Keys {
				if _, has := adds[key]; !has {
					rems[key] = struct{}{}
				}
			}
		}
	}

	//Build state
	keys := make([]string, len(crdt.entries)+len(adds)-len(rems))
	i := 0
	for key, _ := range crdt.entries {
		if _, has := rems[key]; !has {
			keys[i] = key
			i++
		}
	}
	for key := range adds {
		if _, has := crdt.entries[key]; !has {
			keys[i] = key
			i++
		}
	}
	return MapKeysState{Keys: keys}
}

func (crdt *RWEmbMapCrdt) getValue(updsNotYetApplied []*UpdateArguments,
	key string, args ReadArguments) (state EmbMapGetValueState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		//Return right away
		return EmbMapGetValueState{State: crdt.entries[key].Read(args, updsNotYetApplied)}
	}

	//Collect all upds for key
	keyUpds := make([]*UpdateArguments, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
	var noOp UpdateArguments = &NoOp{}
	for _, upd := range updsNotYetApplied {
		switch typedUpd := (*upd).(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				keyUpds = append(keyUpds, &typedUpd.Upd)
			}
		case EmbMapUpdateAll:
			if upd, has := typedUpd.Upds[key]; has {
				keyUpds = append(keyUpds, &upd)
			}
		case MapRemove:
			if key == typedUpd.Key {
				keyUpds = keyUpds[len(keyUpds):]
				keyUpds = append(keyUpds, &noOp)
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if key == embKey {
					keyUpds = keyUpds[len(keyUpds):]
					keyUpds = append(keyUpds, &noOp)
					break
				}
			}
		}
	}

	var embCrdt CRDT
	var has bool
	if (*keyUpds[0] == NoOp{}) {
		//Reset CRDT
		if len(keyUpds) > 1 {
			embCrdt, has = InitializeCrdt((*keyUpds[1]).GetCRDTType(), crdt.replicaID), true
			//Hide remove
			keyUpds = keyUpds[1:]
		}
	}
	if !has {
		//Get CRDT from exiting entry
		embCrdt, has = crdt.entries[key]
		if len(keyUpds) == 0 {
			//CRDT doesn't exist and we got no way of knowing which type it was.
			return EmbMapGetValueState{State: RegisterState{Value: nil}}
		} else {
			embCrdt = InitializeCrdt((*keyUpds[1]).GetCRDTType(), crdt.replicaID)
		}
	}
	return EmbMapGetValueState{State: embCrdt.Read(args, keyUpds)}
}

func (crdt *RWEmbMapCrdt) hasKey(updsNotYetApplied []*UpdateArguments, key string) (state MapHasKeyState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		_, has := crdt.entries[key]
		return MapHasKeyState{HasKey: has}
	}

	//Search from finish to end for the "first" op which refers to key.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := (*updsNotYetApplied[i]).(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: true}
			}
		case EmbMapUpdateAll:
			if _, has := typedUpd.Upds[key]; has {
				return MapHasKeyState{HasKey: true}
			}
		case MapRemove:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: false}
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if embKey == key {
					return MapHasKeyState{HasKey: false}
				}
			}
		}
	}

	//No update for key, so check crdt state
	_, has := crdt.entries[key]
	return MapHasKeyState{HasKey: has}
}

//TODO: Maybe one day implement add and remove with their own methods (i.e., avoid the overhead of creating/handling arrays and maps?)
func (crdt *RWEmbMapCrdt) Update(args UpdateArguments) (downstreamArgs DownstreamArguments) {
	////fmt.Println("Updating:", args)
	switch opType := args.(type) {
	case EmbMapUpdate:
		upds := make(map[string]UpdateArguments)
		upds[opType.Key] = opType.Upd
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(upds)
	case MapRemove:
		keys := make([]string, 1)
		keys[0] = opType.Key
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(keys)
	case EmbMapUpdateAll:
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(opType.Upds)
	case MapRemoveAll:
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(opType.Keys)
	}
	return
}

func (crdt *RWEmbMapCrdt) getUpdateAllDownstreamArgs(upds map[string]UpdateArguments) (downstreamArgs DownstreamArguments) {
	downstreams := make(map[string]DownstreamArguments)
	rmvEntries := make(map[int64]int64)
	//Get downstream args and highest remove clk
	for key, upd := range upds {
		embCrdt, _ := crdt.getOrCreateEmbCrdt(key, upd)
		embUpd := embCrdt.Update(upd)
		if (embUpd != NoOp{} && embUpd.MustReplicate()) {
			downstreams[key] = embUpd
		}
		rmvClk, has := crdt.removes[key]
		if has {
			for replica, pair := range rmvClk {
				existingClk := rmvEntries[replica]
				if pair.ts > existingClk {
					rmvEntries[replica] = pair.ts
				}
			}
		}
	}

	//May happen due to NuCRDTs. In this case, there's no need to downstream
	if len(downstreams) == 0 && len(rmvEntries) == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapUpdateAll{Upds: downstreams, RmvEntries: rmvEntries, ReplicaID: crdt.replicaID}
}

func (crdt *RWEmbMapCrdt) getRemoveAllDownstreamArgs(keys []string) (downstreamArgs DownstreamArguments) {
	toRemove := make([]string, len(keys))
	i := 0
	for _, key := range keys {
		if _, has := crdt.entries[key]; has {
			toRemove[i] = key
			i++
		}
	}
	//No CRDT to remove, so an empty op will do
	if i == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapRemoveAll{Rems: toRemove[:i], ReplicaID: crdt.replicaID, Ts: crdt.rmvClock.GetPos(crdt.replicaID) + 1}
}

func (crdt *RWEmbMapCrdt) Downstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments) (otherDownstreamArgs DownstreamArguments) {
	////fmt.Println("Downstreaming:", downstreamArgs)
	//When applying downstreams in the emb CRDTs, new ops may be returned from a NuCRDT
	effect, otherDownstreamArgs := crdt.applyDownstream(updTs, downstreamArgs, NORMAL)
	//Necessary for inversibleCrdt
	crdt.addToHistory(&updTs, &downstreamArgs, effect)
	return
}

//Note: When reapplying ops, we need to ensure that we don't replay downstreams in the embedded CRDTs
//Hence the use of the boolean
func (crdt *RWEmbMapCrdt) applyDownstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments, isRedo bool) (effect *Effect,
	otherDownstreamArgs DownstreamArguments) {
	var tmpEffect Effect = NoEffect{}
	switch opType := downstreamArgs.(type) {
	case DownstreamRWEmbMapUpdateAll:
		tmpEffect, otherDownstreamArgs = crdt.applyUpdateAll(updTs, opType.Upds, opType.RmvEntries, opType.ReplicaID, isRedo)
	case DownstreamRWEmbMapRemoveAll:
		tmpEffect = crdt.applyRemoveAll(opType.Rems, opType.ReplicaID, opType.Ts)
	}
	return &tmpEffect, otherDownstreamArgs
}

//Note: Assumes that all updates are for the correct embedded CRDT type
func (crdt *RWEmbMapCrdt) applyUpdateAll(updTs clocksi.Timestamp, upds map[string]DownstreamArguments,
	remClks map[int64]int64, remoteID int64, isRedo bool) (effect *RWEmbMapUpdateAllEffect, otherDownstreamArgs DownstreamArguments) {
	effect = &RWEmbMapUpdateAllEffect{
		Updated:   make([]string, len(upds)),
		ReplicaID: remoteID,
		AddedMark: make(map[string]struct{}),
	}
	newDown := make(map[string]DownstreamArguments) //emb NuCRDTs may generate new downstreams
	updatedIndex := 0

	//fmt.Println("[ADD]Applying Add from", remoteID, "with remClks", remClks, "and upds", upds)
	for key, upd := range upds {
		remEntry, has := crdt.removes[key]
		canAdd := !has
		//Remove-wins policy, this add can only have effect if it surparsses all removes.
		if has {
			canAdd = true //If remClks isn't > than remEntry, then canAdd will be set up to false again
			//fmt.Println("[ADD]Have the following removes:", crdt.printMarkedTimestampEntry(remEntry), ". Checking if it can be added with", remClks)
			nMarks := 0
			for replica, pair := range remEntry {
				if remValue, has := remClks[replica]; !has || pair.ts > remValue {
					//fmt.Println("[ADD]Can't add, skipping")
					//Can't apply this update, check next CRDT/upd
					canAdd = false
					break
				} else if pair.mark {
					nMarks++
				}
			}
			if canAdd {
				//fmt.Println("[ADD]Can be added.")
				//Add is after update
				//effect.PreviousRmvs[key] = crdt.removes[key]
				if remotePair, has := remEntry[remoteID]; has {
					if !remotePair.mark {
						effect.AddedMark[key] = struct{}{}
						remotePair.mark = true
						nMarks++
					}
				}
			}
			if nMarks == len(remEntry) {
				/*
					if effect.PreviousRmvClk == nil {
						effect.PreviousRmvClk = make(map[string]map[int64]*markedTimestamp)
					}
					//The state of the mark is irrelevant to the remove effect, thus the map (and its values' pointers) can be shared
					effect.PreviousRmvClk[key] = crdt.removes[key]
					delete(crdt.removes, key)
				*/
			}

		}
		if canAdd {
			//Store effect, even if it's a redo
			effect.Updated[updatedIndex] = key
			updatedIndex++
			if !isRedo {
				//Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
				embCRDT, new := crdt.getOrCreateEmbCrdt(key, upd)
				embDownstream := embCRDT.Downstream(updTs, upd)
				if new {
					////fmt.Println("Storing new emb CRDT")
					//fmt.Println("[ADD]Created new CRDT")
					crdt.entries[key] = embCRDT
				}
				if embDownstream != nil {
					//fmt.Println("[ADD]Embedded generated new downstreams")
					newDown[key] = embDownstream
				}
			}
		}
	}

	effect.Updated = effect.Updated[:updatedIndex]
	if len(newDown) == 0 {
		//fmt.Println("[ADD]No new downstreams, returning.")
		return effect, nil
	}
	//fmt.Println("[ADD]Got new downstreams!")
	return effect, DownstreamRWEmbMapUpdateAll{Upds: newDown, RmvEntries: make(map[int64]int64)}
}

func (crdt *RWEmbMapCrdt) applyRemoveAll(toRem []string, remoteReplicaID int64, remoteClk int64) (effect *RWEmbMapRemoveAllEffect) {
	effect = &RWEmbMapRemoveAllEffect{
		PreviousClk:  crdt.rmvClock.GetPos(remoteReplicaID),
		ReplicaID:    remoteReplicaID,
		RemovedCRDTs: make(map[string]CRDT),
	}
	//fmt.Println("[REMOVE]Applying Remove from", remoteReplicaID, "with clk", remoteClk)
	crdt.rmvClock.UpdatePos(remoteReplicaID, remoteClk)
	for _, key := range toRem {
		remEntry, has := crdt.removes[key]
		if !has {
			//fmt.Println("[REMOVE]Didn't had any previous remove, making an entry in crdt.removes")
			remEntry = make(map[int64]*markedTimestamp)
			crdt.removes[key] = remEntry
		}
		//fmt.Println("[REMOVE]Stored remove pair for replicaID", remoteReplicaID, "with clk", remoteClk)
		remEntry[remoteReplicaID] = &markedTimestamp{ts: remoteClk, mark: false}
		if len(remEntry) > 1 {
			//fmt.Println("[REMOVE]Resetting entries to non-marked as there's at least 2 replicas")
			//Mark all other entries as not marked
			for _, pair := range remEntry {
				pair.mark = false
			}
		}
		existingCRDT, has := crdt.entries[key]
		if has {
			//fmt.Println("[REMOVE]CRDT existed, removing it.")
			effect.RemovedCRDTs[key] = existingCRDT
			delete(crdt.entries, key)
		} else {
			//fmt.Println("[REMOVE]CRDT didn't exist, no changes.")
		}
	}
	//fmt.Println("[REMOVE]Returning.")
	return
}

func (crdt *RWEmbMapCrdt) IsOperationWellTyped(args UpdateArguments) (ok bool, err error) {
	//TODO: Typechecking
	return true, nil
}

//METHODS FOR INVERSIBLE_CRDT

func (crdt *RWEmbMapCrdt) Copy() (copyCRDT InversibleCRDT) {
	newCrdt := RWEmbMapCrdt{
		genericInversibleCRDT: crdt.genericInversibleCRDT.copy(),
		entries:               make(map[string]CRDT),
		removes:               make(map[string]map[int64]*markedTimestamp),
		rmvClock:              crdt.rmvClock.Copy(),
		replicaID:             crdt.replicaID,
	}
	for key, embCrdt := range crdt.entries {
		newCrdt.entries[key] = embCrdt.(InversibleCRDT).Copy()
	}
	for key, rmvMap := range crdt.removes {
		newMap := make(map[int64]*markedTimestamp)
		for replica, value := range rmvMap {
			newMap[replica] = &markedTimestamp{ts: value.ts, mark: value.mark}
		}
		newCrdt.removes[key] = newMap
	}

	return &newCrdt
}

func (crdt *RWEmbMapCrdt) RebuildCRDTToVersion(targetTs clocksi.Timestamp) {
	//We'll keep a log of the CRDTs that need to be rebuilt, for efficiency.
	//There's also an opportunity to do so here with multiple goroutines, but that wouldn't be complete
	//and would recalculate old states of CRDTs that were deleted in the past and thus unecessary.
	crdt.keysToRebuild = make(map[string]struct{})
	crdt.genericInversibleCRDT.rebuildCRDTToVersion(targetTs, crdt.undoEffect, crdt.reapplyOp, crdt.notifyRebuiltComplete)
}

func (crdt *RWEmbMapCrdt) reapplyOp(updArgs DownstreamArguments) (effect *Effect) {
	//The timestamp (nil) is only used by embedded CRDTs, which won't be changed now due to the REDO flag.
	effect, _ = crdt.applyDownstream(nil, updArgs, REDO)
	return effect
}

func (crdt *RWEmbMapCrdt) undoEffect(effect *Effect) {
	switch typedEffect := (*effect).(type) {
	case RWEmbMapUpdateAllEffect:
		crdt.undoUpdateAllEffect(typedEffect.Updated, typedEffect.PreviousRmvClk, typedEffect.AddedMark, typedEffect.ReplicaID)
	case RWEmbMapRemoveAllEffect:
		crdt.undoRemoveAllEffect(typedEffect.RemovedCRDTs, typedEffect.ReplicaID, typedEffect.PreviousClk)
	}
}

func (crdt *RWEmbMapCrdt) undoUpdateAllEffect(updated []string, previousRmvClk map[string]map[int64]*markedTimestamp, addedMark map[string]struct{}, replicaID int64) {
	/*
		//CRDTs that were as removed before this add
		for key, previousClk := range previousRems {
			crdt.removes[key] = previousClk //Should be safe as this is a CRDT copy that won't be changed
			delete(crdt.entries, key)
			delete(crdt.keysToRebuild, key)
		}
		//CRDTs that were updated. Mark them as needed to be updated later
		for _, key := range updated {
			crdt.keysToRebuild[key] = struct{}{}
		}
	*/
	if previousRmvClk != nil {
		for key, entry := range previousRmvClk {
			crdt.removes[key] = entry //Safe since this is a CRDT copy that won't be changed
			delete(crdt.entries, key)
		}
	}
	//Update marks
	for key := range addedMark {
		crdt.removes[key][replicaID].mark = false
	}
	//Update map of CRDTs to be rebuilt
	for _, key := range updated {
		crdt.keysToRebuild[key] = struct{}{}
	}
}

func (crdt *RWEmbMapCrdt) undoRemoveAllEffect(removedCRDTs map[string]CRDT, replicaID int64, previousClk int64) {
	//CRDTs that were removed by this remove. We need to add them back
	for key, embCrdt := range removedCRDTs {
		crdt.entries[key] = embCrdt
		delete(crdt.removes, key)
	}
	crdt.rmvClock.UpdateForcedPos(replicaID, previousClk)
}

func (crdt *RWEmbMapCrdt) notifyRebuiltComplete(currTs *clocksi.Timestamp) {
	//Only redo CRDTs that were altered
	for key := range crdt.keysToRebuild {
		crdt.entries[key].(InversibleCRDT).RebuildCRDTToVersion(*currTs)
	}
	crdt.keysToRebuild = nil
}

//Others

func (crdt *RWEmbMapCrdt) getOrCreateEmbCrdt(key string, upd UpdateArguments) (embCrdt CRDT, new bool) {
	embCrdt, has := crdt.entries[key]
	new = !has
	if !has {
		embCrdt = InitializeCrdt(upd.GetCRDTType(), crdt.replicaID)
	}
	return
}

//Debug, delete this

func (crdt *RWEmbMapCrdt) printMarkedTimestampEntry(entry map[int64]*markedTimestamp) (text string) {
	var builder strings.Builder
	builder.WriteString("map[")
	for key, pair := range entry {
		builder.WriteString(fmt.Sprint(key))
		builder.WriteRune(':')
		builder.WriteString(fmt.Sprint(*pair))
		builder.WriteRune(' ')
	}
	builder.WriteRune(']')
	return builder.String()
}
