package crdt

import (
	"fmt"
	"potionDB/src/clocksi"
	"potionDB/src/proto"
	"strings"

	pb "github.com/golang/protobuf/proto"
)

/*TODO: Bug that affects potencially all CRDTs: in multi-update transactions, each update doesn't
reflect the effects of the previous upds, which can lead to wrong results.
E.g: in a set with uniques, add(a) -> rem(a) in the same transaction leads to wrong result - the
unique generated by add(a) won't be removed by rem(a).
*/

//Note: This CRDT is optimized for adds - this assumes that removes are a rarity.
//TODO: Undos
//TODO: Re-enable marks?

const (
	REDO                        = true
	NORMAL                      = false
	INITIAL_UPDSNOTAPPLIED_SIZE = 10 //Buffer size for updsnotapplied of each embedded CRDT
)

type RWEmbMapCrdt struct {
	*genericInversibleCRDT
	//entries RWEmbCRDT
	entries   map[string]CRDT
	removes   map[string]map[int16]*markedTimestamp //replicaID -> (clk value, mark)
	rmvClock  clocksi.Timestamp
	replicaID int16 //Needed for some embedded CRDTs and for rmvClock
	//Extra metadata for rebuilding old CRDT versions via inversibleCRDT.
	//Should not be copied or transmitted to other replicas
	keysToRebuild map[string]struct{} //Stores the keys of the CRDTs that were changed while going back in time
}

type markedTimestamp struct {
	ts   int64
	mark bool
}

/*
Idea: check archive article but opt OR-Set. But the idea is that a remove increases rmvClock
and sends replicaID's clk. On add, all pairs (replicaID, clk) are sent and an add only is
successful if removes gets emptied.
*/

/*
type RWEmbCRDT struct {
	CRDT
	//ReplicaID -> clock value
	clk map[int64]int64
}
*/

//States returned by queries

type EmbMapEntryState struct {
	States map[string]State
}

type EmbMapGetValueState struct {
	State State
}

type EmbMapHasKeyState struct {
	HasKey bool
}

type EmbMapKeysState struct {
	Keys []string
}

//Also uses queries defined in orMap.go
type EmbMapGetValueArguments struct {
	Key  string
	Args ReadArguments
}

type EmbMapPartialArguments struct {
	Args map[string]ReadArguments
}

//Operations

type EmbMapUpdate struct {
	Key string
	Upd UpdateArguments
}

//TODO: Might be worth it to change this to support multiple updates per key
type EmbMapUpdateAll struct {
	Upds map[string]UpdateArguments
}

//Removes are the same as the ones used in orMap

//Downstream operations

type DownstreamRWEmbMapUpdateAll struct {
	Upds       map[string]DownstreamArguments
	RmvEntries map[int16]int64 //replicaID -> clk value
	ReplicaID  int16
}

type DownstreamRWEmbMapRemoveAll struct {
	Rems      []string
	Ts        int64
	ReplicaID int16
}

//Operation effects for inversibleCRDT

//Add if mark was there or not for the replica. Also need to add the replicaID.
type RWEmbMapUpdateAllEffect struct {
	Updated        []string //Keys for which updates were applied
	ReplicaID      int16
	AddedMark      map[string]struct{}
	PreviousRmvClk map[string]map[int16]*markedTimestamp
}

//Can use previousClk to know if an entry was added to RmvEntries (if previousClk == 0, then a new entry was added)
type RWEmbMapRemoveAllEffect struct {
	RemovedCRDTs map[string]CRDT
	ReplicaID    int16
	PreviousClk  int64 //Previous value of rmvClock[replicaID]
}

func (crdt *RWEmbMapCrdt) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

//Upds
func (args EmbMapUpdate) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args EmbMapUpdateAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

//Downstreams
func (args DownstreamRWEmbMapUpdateAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args DownstreamRWEmbMapRemoveAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args DownstreamRWEmbMapUpdateAll) MustReplicate() bool { return true }

func (args DownstreamRWEmbMapRemoveAll) MustReplicate() bool { return true }

//States
func (args EmbMapEntryState) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args EmbMapEntryState) GetREADType() proto.READType { return proto.READType_FULL }

func (args EmbMapGetValueState) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args EmbMapGetValueState) GetREADType() proto.READType { return proto.READType_GET_VALUE }

func (args EmbMapHasKeyState) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args EmbMapHasKeyState) GetREADType() proto.READType { return proto.READType_HAS_KEY }

func (args EmbMapKeysState) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args EmbMapKeysState) GetREADType() proto.READType { return proto.READType_GET_KEYS }

//Queries
func (args EmbMapGetValueArguments) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args EmbMapGetValueArguments) GetREADType() proto.READType { return proto.READType_GET_VALUE }

func (args EmbMapPartialArguments) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

func (args EmbMapPartialArguments) GetREADType() proto.READType { return proto.READType_GET_VALUES }

//Note: crdt can (and most often will be) nil
func (crdt *RWEmbMapCrdt) Initialize(startTs *clocksi.Timestamp, replicaID int16) (newCrdt CRDT) {
	crdt = &RWEmbMapCrdt{
		genericInversibleCRDT: (&genericInversibleCRDT{}).initialize(startTs),
		entries:               make(map[string]CRDT),
		removes:               make(map[string]map[int16]*markedTimestamp),
		rmvClock:              clocksi.NewClockSiTimestamp(),
		//rmvClock:              clocksi.NewClockSiTimestamp(replicaID),
		replicaID: replicaID,
	}
	newCrdt = crdt
	return
}

//Used to initialize when building a CRDT from a remote snapshot
func (crdt *RWEmbMapCrdt) initializeFromSnapshot(startTs *clocksi.Timestamp, replicaID int16) (sameCRDT *RWEmbMapCrdt) {
	crdt.genericInversibleCRDT, crdt.replicaID = (&genericInversibleCRDT{}).initialize(startTs), replicaID
	return crdt
}

func (crdt *RWEmbMapCrdt) Read(args ReadArguments, updsNotYetApplied []*UpdateArguments) (state State) {
	switch typedArg := args.(type) {
	case StateReadArguments:
		return crdt.getState(updsNotYetApplied)
	case GetKeysArguments:
		return crdt.getKeys(updsNotYetApplied)
	case EmbMapGetValueArguments:
		return crdt.getValue(updsNotYetApplied, typedArg.Key, typedArg.Args)
	case HasKeyArguments:
		return crdt.hasKey(updsNotYetApplied, typedArg.Key)
	case EmbMapPartialArguments:
		return crdt.getPartialState(updsNotYetApplied, typedArg.Args)
	default:
		fmt.Printf("[RWEmb]Unknown read type: %T\n", args)
	}
	return nil
}

func (crdt *RWEmbMapCrdt) getState(updsNotYetApplied []*UpdateArguments) (state EmbMapEntryState) {
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			states[key] = embCrdt.Read(StateReadArguments{}, updsNotYetApplied)
		}
		return EmbMapEntryState{States: states}
	}

	/*
		Each entry may contain either:
		A) multiple updates, at most one for each CRDT;
		B) multiple removes
		Since we have multiple entries, we may also have multiple updates for a CRDT.
		Including possibly a remove in the middle of a CRDT that later gets updated...

		So, idea:
		Have a map of key -> [Updates].
		Stores updates normally.
		Use NoOp{} to signal removes (and hide all ops before).
	*/

	applyByCRDT := make(map[string][]*UpdateArguments)
	var noOp UpdateArguments = NoOp{}
	for _, upds := range updsNotYetApplied {
		switch convUpds := (*upds).(type) {
		case EmbMapUpdate:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			applyByCRDT[convUpds.Key] = append(entry, &convUpds.Upd)
		case EmbMapUpdateAll:
			for key, upd := range convUpds.Upds {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				applyByCRDT[key] = append(entry, &upd)
			}
		case MapRemove:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
			applyByCRDT[convUpds.Key] = append(entry, &noOp)
		case MapRemoveAll:
			for _, key := range convUpds.Keys {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
				applyByCRDT[key] = append(entry, &noOp)
			}
		}
	}

	//Now, apply
	for key, upds := range applyByCRDT {
		if (*upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				states[key] = InitializeCrdt((*upds[1]).GetCRDTType(),
					crdt.replicaID).Read(StateReadArguments{}, upds[1:])
			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (*upds[0]))
			states[key] = embCrdt.Read(StateReadArguments{}, upds)
		}
	}

	//Also need to include CRDTs that aren't referred in applyByCRDT
	for key, embCrdt := range crdt.entries {
		if _, has := applyByCRDT[key]; !has {
			states[key] = embCrdt.Read(StateReadArguments{}, []*UpdateArguments{})
		}
	}
	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getPartialState(updsNotYetApplied []*UpdateArguments, args map[string]ReadArguments) (state EmbMapEntryState) {
	//Very similar to getState

	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, arg := range args {
			if embCrdt, has := crdt.entries[key]; has {
				states[key] = embCrdt.Read(arg, updsNotYetApplied)
			}
		}
		return EmbMapEntryState{States: states}
	}

	/*
		Each entry may contain either:
		A) multiple updates, at most one for each CRDT;
		B) multiple removes
		Since we have multiple entries, we may also have multiple updates for a CRDT.
		Including possibly a remove in the middle of a CRDT that later gets updated...

		So, idea:
		Have a map of key -> [Updates].
		Stores updates normally.
		Use NoOp{} to signal removes (and hide all ops before).
	*/

	applyByCRDT := make(map[string][]*UpdateArguments)
	var noOp UpdateArguments = NoOp{}
	for _, upds := range updsNotYetApplied {
		switch convUpds := (*upds).(type) {
		case EmbMapUpdate:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			applyByCRDT[convUpds.Key] = append(entry, &convUpds.Upd)
		case EmbMapUpdateAll:
			for key, upd := range convUpds.Upds {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				applyByCRDT[key] = append(entry, &upd)
			}
		case MapRemove:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
			applyByCRDT[convUpds.Key] = append(entry, &noOp)
		case MapRemoveAll:
			for _, key := range convUpds.Keys {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]*UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
				applyByCRDT[key] = append(entry, &noOp)
			}
		}
	}

	for key, arg := range args {
		if upds, has := applyByCRDT[key]; has {
			if (*upds[0] == NoOp{}) {
				if len(upds) > 1 {
					//Start from scratch
					states[key] = InitializeCrdt((*upds[1]).GetCRDTType(),
						crdt.replicaID).Read(StateReadArguments{}, upds[1:])
				} else {
					//Removed CRDT, thus doesn't belong to state
					continue
				}
			} else {
				embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (*upds[0]))
				states[key] = embCrdt.Read(StateReadArguments{}, upds)
			}
		} else if embCrdt, has := crdt.entries[key]; has {
			states[key] = embCrdt.Read(arg, []*UpdateArguments{})
		}
	}

	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getKeys(updsNotYetApplied []*UpdateArguments) (state MapKeysState) {
	//Literally a copy from ORMap. Sigh
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		keys := make([]string, len(crdt.entries))
		i := 0
		for key, _ := range crdt.entries {
			keys[i] = key
			i++
		}
		return MapKeysState{Keys: keys}
	}

	adds := make(map[string]struct{})
	rems := make(map[string]struct{})

	//Key idea: for each key, the latest update is the only one that matters, hence start at the end.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := (*updsNotYetApplied[i]).(type) {
		case EmbMapUpdate:
			if _, has := rems[typedUpd.Key]; !has {
				adds[typedUpd.Key] = struct{}{}
			}
		case MapRemove:
			if _, has := adds[typedUpd.Key]; !has {
				rems[typedUpd.Key] = struct{}{}
			}
		case EmbMapUpdateAll:
			for key, _ := range typedUpd.Upds {
				if _, has := rems[key]; !has {
					adds[key] = struct{}{}
				}
			}
		case MapRemoveAll:
			for _, key := range typedUpd.Keys {
				if _, has := adds[key]; !has {
					rems[key] = struct{}{}
				}
			}
		}
	}

	//Build state
	keys := make([]string, len(crdt.entries)+len(adds)-len(rems))
	i := 0
	for key, _ := range crdt.entries {
		if _, has := rems[key]; !has {
			keys[i] = key
			i++
		}
	}
	for key := range adds {
		if _, has := crdt.entries[key]; !has {
			keys[i] = key
			i++
		}
	}
	return MapKeysState{Keys: keys}
}

func (crdt *RWEmbMapCrdt) getValue(updsNotYetApplied []*UpdateArguments,
	key string, args ReadArguments) (state EmbMapGetValueState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		//Return right away
		return EmbMapGetValueState{State: crdt.entries[key].Read(args, updsNotYetApplied)}
	}

	//Collect all upds for key
	keyUpds := make([]*UpdateArguments, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
	var noOp UpdateArguments = &NoOp{}
	for _, upd := range updsNotYetApplied {
		switch typedUpd := (*upd).(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				keyUpds = append(keyUpds, &typedUpd.Upd)
			}
		case EmbMapUpdateAll:
			if upd, has := typedUpd.Upds[key]; has {
				keyUpds = append(keyUpds, &upd)
			}
		case MapRemove:
			if key == typedUpd.Key {
				keyUpds = keyUpds[len(keyUpds):]
				keyUpds = append(keyUpds, &noOp)
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if key == embKey {
					keyUpds = keyUpds[len(keyUpds):]
					keyUpds = append(keyUpds, &noOp)
					break
				}
			}
		}
	}

	var embCrdt CRDT
	var has bool
	if (*keyUpds[0] == NoOp{}) {
		//Reset CRDT
		if len(keyUpds) > 1 {
			embCrdt, has = InitializeCrdt((*keyUpds[1]).GetCRDTType(), crdt.replicaID), true
			//Hide remove
			keyUpds = keyUpds[1:]
		}
	}
	if !has {
		//Get CRDT from exiting entry
		embCrdt, has = crdt.entries[key]
		if len(keyUpds) == 0 {
			//CRDT doesn't exist and we got no way of knowing which type it was.
			return EmbMapGetValueState{State: RegisterState{Value: nil}}
		} else {
			embCrdt = InitializeCrdt((*keyUpds[1]).GetCRDTType(), crdt.replicaID)
		}
	}
	return EmbMapGetValueState{State: embCrdt.Read(args, keyUpds)}
}

func (crdt *RWEmbMapCrdt) hasKey(updsNotYetApplied []*UpdateArguments, key string) (state MapHasKeyState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		_, has := crdt.entries[key]
		return MapHasKeyState{HasKey: has}
	}

	//Search from finish to end for the "first" op which refers to key.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := (*updsNotYetApplied[i]).(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: true}
			}
		case EmbMapUpdateAll:
			if _, has := typedUpd.Upds[key]; has {
				return MapHasKeyState{HasKey: true}
			}
		case MapRemove:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: false}
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if embKey == key {
					return MapHasKeyState{HasKey: false}
				}
			}
		}
	}

	//No update for key, so check crdt state
	_, has := crdt.entries[key]
	return MapHasKeyState{HasKey: has}
}

//TODO: Maybe one day implement add and remove with their own methods (i.e., avoid the overhead of creating/handling arrays and maps?)
func (crdt *RWEmbMapCrdt) Update(args UpdateArguments) (downstreamArgs DownstreamArguments) {
	////fmt.Println("Updating:", args)
	switch opType := args.(type) {
	case EmbMapUpdate:
		upds := make(map[string]UpdateArguments)
		upds[opType.Key] = opType.Upd
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(upds)
	case MapRemove:
		keys := make([]string, 1)
		keys[0] = opType.Key
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(keys)
	case EmbMapUpdateAll:
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(opType.Upds)
	case MapRemoveAll:
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(opType.Keys)
	default:
		fmt.Printf("[RWEmbMap]Didn't apply any update!!! Type received: %T\n", args)
	}
	return
}

func (crdt *RWEmbMapCrdt) getUpdateAllDownstreamArgs(upds map[string]UpdateArguments) (downstreamArgs DownstreamArguments) {
	downstreams := make(map[string]DownstreamArguments)
	rmvEntries := make(map[int16]int64)
	//Get downstream args and highest remove clk
	for key, upd := range upds {
		embCrdt, _ := crdt.getOrCreateEmbCrdt(key, upd)
		embUpd := embCrdt.Update(upd)
		if (embUpd != NoOp{} && embUpd.MustReplicate()) {
			downstreams[key] = embUpd
		}
		rmvClk, has := crdt.removes[key]
		if has {
			for replica, pair := range rmvClk {
				existingClk := rmvEntries[replica]
				if pair.ts > existingClk {
					rmvEntries[replica] = pair.ts
				}
			}
		}
	}

	//May happen due to NuCRDTs. In this case, there's no need to downstream
	if len(downstreams) == 0 && len(rmvEntries) == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapUpdateAll{Upds: downstreams, RmvEntries: rmvEntries, ReplicaID: crdt.replicaID}
}

func (crdt *RWEmbMapCrdt) getRemoveAllDownstreamArgs(keys []string) (downstreamArgs DownstreamArguments) {
	toRemove := make([]string, len(keys))
	i := 0
	for _, key := range keys {
		if _, has := crdt.entries[key]; has {
			toRemove[i] = key
			i++
		}
	}
	//No CRDT to remove, so an empty op will do
	if i == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapRemoveAll{Rems: toRemove[:i], ReplicaID: crdt.replicaID, Ts: crdt.rmvClock.GetPos(crdt.replicaID) + 1}
}

func (crdt *RWEmbMapCrdt) Downstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments) (otherDownstreamArgs DownstreamArguments) {
	////fmt.Println("Downstreaming:", downstreamArgs)
	//When applying downstreams in the emb CRDTs, new ops may be returned from a NuCRDT
	effect, otherDownstreamArgs := crdt.applyDownstream(updTs, downstreamArgs, NORMAL)
	//Necessary for inversibleCrdt
	crdt.addToHistory(&updTs, &downstreamArgs, effect)
	return
}

//Note: When reapplying ops, we need to ensure that we don't replay downstreams in the embedded CRDTs
//Hence the use of the boolean
func (crdt *RWEmbMapCrdt) applyDownstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments, isRedo bool) (effect *Effect,
	otherDownstreamArgs DownstreamArguments) {
	var tmpEffect Effect = NoEffect{}
	switch opType := downstreamArgs.(type) {
	case DownstreamRWEmbMapUpdateAll:
		tmpEffect, otherDownstreamArgs = crdt.applyUpdateAll(updTs, opType.Upds, opType.RmvEntries, opType.ReplicaID, isRedo)
	case DownstreamRWEmbMapRemoveAll:
		tmpEffect = crdt.applyRemoveAll(opType.Rems, opType.ReplicaID, opType.Ts)
	}
	return &tmpEffect, otherDownstreamArgs
}

//Note: Assumes that all updates are for the correct embedded CRDT type
func (crdt *RWEmbMapCrdt) applyUpdateAll(updTs clocksi.Timestamp, upds map[string]DownstreamArguments,
	remClks map[int16]int64, remoteID int16, isRedo bool) (effect *RWEmbMapUpdateAllEffect, otherDownstreamArgs DownstreamArguments) {
	effect = &RWEmbMapUpdateAllEffect{
		Updated:   make([]string, len(upds)),
		ReplicaID: remoteID,
		AddedMark: make(map[string]struct{}),
	}
	newDown := make(map[string]DownstreamArguments) //emb NuCRDTs may generate new downstreams
	updatedIndex := 0

	//fmt.Println("[ADD]Applying Add from", remoteID, "with remClks", remClks, "and upds", upds)
	for key, upd := range upds {
		remEntry, has := crdt.removes[key]
		canAdd := !has
		//Remove-wins policy, this add can only have effect if it surparsses all removes.
		if has {
			canAdd = true //If remClks isn't > than remEntry, then canAdd will be set up to false again
			//fmt.Println("[ADD]Have the following removes:", crdt.printMarkedTimestampEntry(remEntry), ". Checking if it can be added with", remClks)
			nMarks := 0
			for replica, pair := range remEntry {
				if remValue, has := remClks[replica]; !has || pair.ts > remValue {
					//fmt.Println("[ADD]Can't add, skipping")
					//Can't apply this update, check next CRDT/upd
					canAdd = false
					break
				} else if pair.mark {
					nMarks++
				}
			}
			if canAdd {
				//fmt.Println("[ADD]Can be added.")
				//Add is after update
				//effect.PreviousRmvs[key] = crdt.removes[key]
				if remotePair, has := remEntry[remoteID]; has {
					if !remotePair.mark {
						effect.AddedMark[key] = struct{}{}
						remotePair.mark = true
						nMarks++
					}
				}
			}
			if nMarks == len(remEntry) {
				/*
					if effect.PreviousRmvClk == nil {
						effect.PreviousRmvClk = make(map[string]map[int64]*markedTimestamp)
					}
					//The state of the mark is irrelevant to the remove effect, thus the map (and its values' pointers) can be shared
					effect.PreviousRmvClk[key] = crdt.removes[key]
					delete(crdt.removes, key)
				*/
			}

		}
		if canAdd {
			//Store effect, even if it's a redo
			effect.Updated[updatedIndex] = key
			updatedIndex++
			if !isRedo {
				//Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
				embCRDT, new := crdt.getOrCreateEmbCrdt(key, upd)
				embDownstream := embCRDT.Downstream(updTs, upd)
				if new {
					////fmt.Println("Storing new emb CRDT")
					//fmt.Println("[ADD]Created new CRDT")
					crdt.entries[key] = embCRDT
				}
				if embDownstream != nil {
					//fmt.Println("[ADD]Embedded generated new downstreams")
					newDown[key] = embDownstream
				}
			}
		}
	}

	effect.Updated = effect.Updated[:updatedIndex]
	if len(newDown) == 0 {
		//fmt.Println("[ADD]No new downstreams, returning.")
		return effect, nil
	}
	//fmt.Println("[ADD]Got new downstreams!")
	//TODO: is this correct?
	return effect, DownstreamRWEmbMapUpdateAll{Upds: newDown, RmvEntries: make(map[int16]int64)}
}

func (crdt *RWEmbMapCrdt) applyRemoveAll(toRem []string, remoteReplicaID int16, remoteClk int64) (effect *RWEmbMapRemoveAllEffect) {
	effect = &RWEmbMapRemoveAllEffect{
		PreviousClk:  crdt.rmvClock.GetPos(remoteReplicaID),
		ReplicaID:    remoteReplicaID,
		RemovedCRDTs: make(map[string]CRDT),
	}
	//fmt.Println("[REMOVE]Applying Remove from", remoteReplicaID, "with clk", remoteClk)
	crdt.rmvClock.UpdatePos(remoteReplicaID, remoteClk)
	for _, key := range toRem {
		remEntry, has := crdt.removes[key]
		if !has {
			//fmt.Println("[REMOVE]Didn't had any previous remove, making an entry in crdt.removes")
			remEntry = make(map[int16]*markedTimestamp)
			crdt.removes[key] = remEntry
		}
		//fmt.Println("[REMOVE]Stored remove pair for replicaID", remoteReplicaID, "with clk", remoteClk)
		remEntry[remoteReplicaID] = &markedTimestamp{ts: remoteClk, mark: false}
		if len(remEntry) > 1 {
			//fmt.Println("[REMOVE]Resetting entries to non-marked as there's at least 2 replicas")
			//Mark all other entries as not marked
			for _, pair := range remEntry {
				pair.mark = false
			}
		}
		existingCRDT, has := crdt.entries[key]
		if has {
			//fmt.Println("[REMOVE]CRDT existed, removing it.")
			effect.RemovedCRDTs[key] = existingCRDT
			delete(crdt.entries, key)
		} else {
			//fmt.Println("[REMOVE]CRDT didn't exist, no changes.")
		}
	}
	//fmt.Println("[REMOVE]Returning.")
	return
}

func (crdt *RWEmbMapCrdt) IsOperationWellTyped(args UpdateArguments) (ok bool, err error) {
	//TODO: Typechecking
	return true, nil
}

//METHODS FOR INVERSIBLE_CRDT

func (crdt *RWEmbMapCrdt) Copy() (copyCRDT InversibleCRDT) {
	newCrdt := RWEmbMapCrdt{
		genericInversibleCRDT: crdt.genericInversibleCRDT.copy(),
		entries:               make(map[string]CRDT),
		removes:               make(map[string]map[int16]*markedTimestamp),
		rmvClock:              crdt.rmvClock.Copy(),
		replicaID:             crdt.replicaID,
	}
	for key, embCrdt := range crdt.entries {
		newCrdt.entries[key] = embCrdt.(InversibleCRDT).Copy()
	}
	for key, rmvMap := range crdt.removes {
		newMap := make(map[int16]*markedTimestamp)
		for replica, value := range rmvMap {
			newMap[replica] = &markedTimestamp{ts: value.ts, mark: value.mark}
		}
		newCrdt.removes[key] = newMap
	}

	return &newCrdt
}

func (crdt *RWEmbMapCrdt) RebuildCRDTToVersion(targetTs clocksi.Timestamp) {
	//We'll keep a log of the CRDTs that need to be rebuilt, for efficiency.
	//There's also an opportunity to do so here with multiple goroutines, but that wouldn't be complete
	//and would recalculate old states of CRDTs that were deleted in the past and thus unecessary.
	crdt.keysToRebuild = make(map[string]struct{})
	crdt.genericInversibleCRDT.rebuildCRDTToVersion(targetTs, crdt.undoEffect, crdt.reapplyOp, crdt.notifyRebuiltComplete)
}

func (crdt *RWEmbMapCrdt) reapplyOp(updArgs DownstreamArguments) (effect *Effect) {
	//The timestamp (nil) is only used by embedded CRDTs, which won't be changed now due to the REDO flag.
	effect, _ = crdt.applyDownstream(nil, updArgs, REDO)
	return effect
}

func (crdt *RWEmbMapCrdt) undoEffect(effect *Effect) {
	switch typedEffect := (*effect).(type) {
	case RWEmbMapUpdateAllEffect:
		crdt.undoUpdateAllEffect(typedEffect.Updated, typedEffect.PreviousRmvClk, typedEffect.AddedMark, typedEffect.ReplicaID)
	case RWEmbMapRemoveAllEffect:
		crdt.undoRemoveAllEffect(typedEffect.RemovedCRDTs, typedEffect.ReplicaID, typedEffect.PreviousClk)
	}
}

func (crdt *RWEmbMapCrdt) undoUpdateAllEffect(updated []string, previousRmvClk map[string]map[int16]*markedTimestamp, addedMark map[string]struct{}, replicaID int16) {
	/*
		//CRDTs that were as removed before this add
		for key, previousClk := range previousRems {
			crdt.removes[key] = previousClk //Should be safe as this is a CRDT copy that won't be changed
			delete(crdt.entries, key)
			delete(crdt.keysToRebuild, key)
		}
		//CRDTs that were updated. Mark them as needed to be updated later
		for _, key := range updated {
			crdt.keysToRebuild[key] = struct{}{}
		}
	*/
	if previousRmvClk != nil {
		for key, entry := range previousRmvClk {
			crdt.removes[key] = entry //Safe since this is a CRDT copy that won't be changed
			delete(crdt.entries, key)
		}
	}
	//Update marks
	for key := range addedMark {
		crdt.removes[key][replicaID].mark = false
	}
	//Update map of CRDTs to be rebuilt
	for _, key := range updated {
		crdt.keysToRebuild[key] = struct{}{}
	}
}

func (crdt *RWEmbMapCrdt) undoRemoveAllEffect(removedCRDTs map[string]CRDT, replicaID int16, previousClk int64) {
	//CRDTs that were removed by this remove. We need to add them back
	for key, embCrdt := range removedCRDTs {
		crdt.entries[key] = embCrdt
		delete(crdt.removes, key)
	}
	crdt.rmvClock.UpdateForcedPos(replicaID, previousClk)
}

func (crdt *RWEmbMapCrdt) notifyRebuiltComplete(currTs *clocksi.Timestamp) {
	//Only redo CRDTs that were altered
	for key := range crdt.keysToRebuild {
		crdt.entries[key].(InversibleCRDT).RebuildCRDTToVersion(*currTs)
	}
	crdt.keysToRebuild = nil
}

//Others

func (crdt *RWEmbMapCrdt) getOrCreateEmbCrdt(key string, upd UpdateArguments) (embCrdt CRDT, new bool) {
	embCrdt, has := crdt.entries[key]
	new = !has
	if !has {
		embCrdt = InitializeCrdt(upd.GetCRDTType(), crdt.replicaID)
	}
	return
}

//Debug, delete this

func (crdt *RWEmbMapCrdt) printMarkedTimestampEntry(entry map[int64]*markedTimestamp) (text string) {
	var builder strings.Builder
	builder.WriteString("map[")
	for key, pair := range entry {
		builder.WriteString(fmt.Sprint(key))
		builder.WriteRune(':')
		builder.WriteString(fmt.Sprint(*pair))
		builder.WriteRune(' ')
	}
	builder.WriteRune(']')
	return builder.String()
}

//Protobuf functions
//Note: the states/ops common with OrMap are defined there

func (crdtOp EmbMapUpdateAll) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	protoAdds := protobuf.GetMapop().GetUpdates()
	crdtOp.Upds = make(map[string]UpdateArguments)
	for _, mapUpd := range protoAdds {
		crdtOp.Upds[string(mapUpd.GetKey().GetKey())] =
			*UpdateProtoToAntidoteUpdate(mapUpd.GetUpdate(), mapUpd.GetKey().GetType())
	}
	return crdtOp
}

func (crdtOp EmbMapUpdateAll) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Mapop: &proto.ApbMapUpdate{
		Updates:     createMapNestedOps(crdtOp.Upds),
		RemovedKeys: []*proto.ApbMapKey{},
	}}
}

func (crdtOp EmbMapUpdate) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	protoAdd := protobuf.GetMapop().GetUpdates()[0]
	crdtOp.Key = string(protoAdd.GetKey().GetKey())
	crdtOp.Upd = *UpdateProtoToAntidoteUpdate(protoAdd.GetUpdate(), protoAdd.GetKey().GetType())
	return crdtOp
}

func (crdtOp EmbMapUpdate) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Mapop: &proto.ApbMapUpdate{
		Updates:     createMapNestedOps(map[string]UpdateArguments{crdtOp.Key: crdtOp.Upd}),
		RemovedKeys: []*proto.ApbMapKey{},
	}}
}

func (crdtState EmbMapEntryState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	crdtState.States = make(map[string]State)

	if entries := protobuf.GetMap().GetEntries(); entries != nil {
		var pKey *proto.ApbMapKey
		for _, entry := range entries {
			pKey = entry.GetKey()
			//In this case the inner reads are also full read for sure. Might be worth changing this in the future though.
			crdtState.States[string(pKey.GetKey())] = ReadRespProtoToAntidoteState(entry.GetValue(), pKey.GetType(), proto.READType_FULL)
		}
	} else {
		//Partial read
		mapProto := protobuf.GetPartread().GetMap().GetGetvalues()
		protoKeys, protoValues := mapProto.GetKeys(), mapProto.GetValues()
		for i, protoValue := range protoValues {
			innerCrdtType, innerReadType := protoValue.GetCrdttype(), protoValue.GetParttype()
			crdtState.States[string(protoKeys[i])] = ReadRespProtoToAntidoteState(protoValue.GetValue(), innerCrdtType, innerReadType)
		}
	}

	return crdtState
}

func (crdtState EmbMapEntryState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	return &proto.ApbReadObjectResp{Map: &proto.ApbGetMapResp{Entries: crdtsToApbMapEntries(crdtState.States)}}
}

func (crdtState EmbMapHasKeyState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	crdtState.HasKey = protobuf.GetPartread().GetMap().GetHaskey().GetHas()
	return crdtState
}

func (crdtState EmbMapHasKeyState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	return &proto.ApbReadObjectResp{Partread: &proto.ApbPartialReadResp{Map: &proto.ApbMapPartialReadResp{
		Haskey: &proto.ApbMapHasKeyReadResp{Has: pb.Bool(crdtState.HasKey)},
	}}}
}

func (crdtState EmbMapKeysState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	crdtState.Keys = protobuf.GetPartread().GetMap().GetGetkeys().GetKeys()
	return crdtState
}

func (crdtState EmbMapKeysState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	return &proto.ApbReadObjectResp{Partread: &proto.ApbPartialReadResp{Map: &proto.ApbMapPartialReadResp{
		Getkeys: &proto.ApbMapGetKeysReadResp{Keys: crdtState.Keys},
	}}}
}

func (crdtState EmbMapGetValueState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	mapProto := protobuf.GetPartread().GetMap().GetGetvalue()
	innerCrdtType, innerReadType := mapProto.GetCrdttype(), mapProto.GetParttype()
	crdtState.State = ReadRespProtoToAntidoteState(mapProto.GetValue(), innerCrdtType, innerReadType)
	return crdtState
}

func (crdtState EmbMapGetValueState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	innerCrdtType, innerReadType := crdtState.State.GetCRDTType(), crdtState.State.GetREADType()
	return &proto.ApbReadObjectResp{Partread: &proto.ApbPartialReadResp{Map: &proto.ApbMapPartialReadResp{
		Getvalue: &proto.ApbMapGetValueResp{
			Value: crdtState.State.(ProtoState).ToReadResp(), Crdttype: &innerCrdtType, Parttype: &innerReadType,
		},
	}}}
}

func (args EmbMapGetValueArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	getValueProto := protobuf.GetMap().GetGetvalue()
	protoArgs := getValueProto.GetArgs()
	if protoArgs == nil {
		//Read whole inner state
		return EmbMapGetValueArguments{Key: string(getValueProto.GetKey()), Args: StateReadArguments{}}
	}
	//Read part of inner state
	innerCrdtType, innerReadType := protoArgs.GetType(), protoArgs.GetReadtype()
	args.Key = string(getValueProto.GetKey())
	args.Args = *PartialReadOpToAntidoteRead(protoArgs.GetArgs(), innerCrdtType, innerReadType)
	return args
}

func (args EmbMapPartialArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	args.Args = make(map[string]ReadArguments)
	getValuesProto := protobuf.GetMap().GetGetvalues()
	byteKeys, argsProto := getValuesProto.GetKeys(), getValuesProto.GetArgs()

	for i, argProto := range argsProto {
		args.Args[string(byteKeys[i])] = *PartialReadOpToAntidoteRead(argProto.GetArgs(), argProto.GetType(), argProto.GetReadtype())
	}
	return args
}

func (args EmbMapGetValueArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Getvalue: &proto.ApbMapGetValueRead{
		Key:  []byte(args.Key),
		Args: createMapGetValuesRead(args.Args),
	}}}
}

func (args EmbMapPartialArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	keys := make([][]byte, len(args.Args))
	argsProtos := make([]*proto.ApbMapEmbPartialArgs, len(args.Args))
	i := 0
	for key, arg := range args.Args {
		keys[i] = []byte(key)
		argsProtos[i] = createMapGetValuesRead(arg)
		i++
	}

	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Getvalues: &proto.ApbMapGetValuesRead{Keys: keys, Args: argsProtos}}}
}

func (downOp DownstreamRWEmbMapUpdateAll) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	adds := protobuf.GetRwembmapOp().GetAdds()
	upds, clk := adds.GetUpds(), adds.GetVc()
	downOp.Upds, downOp.RmvEntries = make(map[string]DownstreamArguments), make(map[int16]int64)

	for _, upd := range upds {
		downOp.Upds[string(upd.GetKey())] = DownstreamProtoToAntidoteDownstream(upd.GetUpd(), upd.GetType())
	}
	for _, protoEntry := range clk {
		downOp.RmvEntries[int16(protoEntry.GetSenderID())] = protoEntry.GetReplicaTs()
	}
	return downOp
}

func (downOp DownstreamRWEmbMapRemoveAll) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	rems := protobuf.GetRwembmapOp().GetRems()
	downOp.Rems, downOp.Ts, downOp.ReplicaID = rems.GetKeys(), rems.GetTs(), int16(rems.GetReplicaID())
	return downOp
}

func (downOp DownstreamRWEmbMapUpdateAll) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	upds, vc := make([]*proto.ProtoEmbMapUpd, len(downOp.Upds)), make([]*proto.ProtoStableClock, len(downOp.RmvEntries))
	i, j := 0, 0
	for key, upd := range downOp.Upds {
		crdtType := upd.GetCRDTType()
		upds[i] = &proto.ProtoEmbMapUpd{Key: []byte(key), Type: &crdtType, Upd: upd.(ProtoDownUpd).ToReplicatorObj()}
		i++
	}
	for key, clk := range downOp.RmvEntries {
		vc[j] = &proto.ProtoStableClock{SenderID: pb.Int32(int32(key)), ReplicaTs: pb.Int64(clk)}
		j++
	}
	return &proto.ProtoOpDownstream{RwembmapOp: &proto.ProtoRWEmbMapDownstream{
		Adds: &proto.ProtoRWEmbMapUpdates{Upds: upds, Vc: vc, ReplicaID: pb.Int32(int32(downOp.ReplicaID))},
	}}
}

func (downOp DownstreamRWEmbMapRemoveAll) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	return &proto.ProtoOpDownstream{RwembmapOp: &proto.ProtoRWEmbMapDownstream{
		Rems: &proto.ProtoRWEmbMapRemoves{Keys: downOp.Rems, ReplicaID: pb.Int32(int32(downOp.ReplicaID)), Ts: pb.Int64(downOp.Ts)},
	}}
}

func (crdt *RWEmbMapCrdt) ToProtoState() (protobuf *proto.ProtoState) {
	protoCRDTs, protoRems, protoClk := make([]*proto.ProtoEmbMapEntry, len(crdt.entries)), make([]*proto.ProtoEmbMapRemove, len(crdt.removes)), crdt.rmvClock.ToBytes()
	i, j, k := 0, 0, 0
	var currRmvClk []*proto.ProtoStableClock
	for key, crdt := range crdt.entries {
		crdtType := crdt.GetCRDTType()
		protoCRDTs[i] = &proto.ProtoEmbMapEntry{Key: &key, Type: &crdtType, State: (crdt.(ProtoCRDT)).ToProtoState()}
		i++
	}
	for key, rmvMap := range crdt.removes {
		currRmvClk = make([]*proto.ProtoStableClock, len(rmvMap))
		for replicaID, markedTs := range rmvMap {
			currRmvClk[k] = &proto.ProtoStableClock{SenderID: pb.Int32(int32(replicaID)), ReplicaTs: &markedTs.ts}
			k++
		}
		protoRems[j] = &proto.ProtoEmbMapRemove{Key: &key, Clks: currRmvClk}
		j++
	}

	return &proto.ProtoState{Embmap: &proto.ProtoEmbMapState{Crdts: protoCRDTs, Removes: protoRems, RmvClock: protoClk}}
}

func (crdt *RWEmbMapCrdt) FromProtoState(proto *proto.ProtoState, ts *clocksi.Timestamp, replicaID int16) (newCRDT CRDT) {
	protoMap := proto.GetEmbmap()
	protoCRDTs, protoRmvs, protoClk := protoMap.GetCrdts(), protoMap.GetRemoves(), protoMap.GetRmvClock()
	entries, removes := make(map[string]CRDT, len(protoCRDTs)), make(map[string]map[int16]*markedTimestamp, len(protoRmvs))
	var currRmvMap map[int16]*markedTimestamp
	for _, protoEntry := range protoCRDTs {
		entries[protoEntry.GetKey()] = StateProtoToCrdt(protoEntry.GetState(), protoEntry.GetType(), ts, replicaID)
	}
	for _, protoRmv := range protoRmvs {
		currRmvMap = make(map[int16]*markedTimestamp)
		for _, clkProto := range protoRmv.GetClks() {
			currRmvMap[int16(clkProto.GetSenderID())] = &markedTimestamp{ts: clkProto.GetReplicaTs(), mark: true}
		}
		removes[protoRmv.GetKey()] = currRmvMap
	}

	return (&RWEmbMapCrdt{entries: entries, removes: removes, rmvClock: clocksi.ClockSiTimestamp{}.FromBytes(protoClk),
		replicaID: crdt.replicaID}).initializeFromSnapshot(ts, replicaID)
}
