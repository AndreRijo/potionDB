package crdt

import "clocksi"

type CRDT interface {
	//Note: replicaID may not be required by every CRDT - for those, any value can be passed.
	Initialize(startTs *clocksi.Timestamp, replicaID int64) (newCrdt CRDT)

	Read(args ReadArguments, updsNotYetApplied []*UpdateArguments) (state State)

	Update(args UpdateArguments) (downstreamArgs DownstreamArguments)

	//For now only non-uniform CRDTs need to return upds when downstreaming
	Downstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments) (otherDownstreamArgs DownstreamArguments)

	//GetVersion() (ts clocksi.Timestamp) //TODO: This is probably not needed at all

	IsOperationWellTyped(args UpdateArguments) (ok bool, err error)
}

//The idea is to include here the methods/data common to every CRDT. For now, there's... nothing
type genericCRDT struct {
}

//Copy of antidote.pb.go to avoid import cycles
type CRDTType int32
type READType int32

type State interface {
	GetCRDTType() CRDTType
}

type PartialState interface {
	GetREADType() READType
}

//Represents the update arguments specific to each CRDT.
type UpdateArguments interface {
	GetCRDTType() CRDTType
}

//Represents the update arguments generated by the prepare phase
type DownstreamArguments interface {
	GetCRDTType() CRDTType
	//Returns false if this operation doesn't need to be replicated for every replica or if it is a no-op
	MustReplicate() bool
}

//Represents the read arguments specific to each CRDT.
type ReadArguments interface {
}

//Represents a read of the whole state
type StateReadArguments struct {
}

type NoOp struct{}

func (op NoOp) GetCRDTType() CRDTType { return -1 }

func (op NoOp) MustReplicate() bool { return false }

type ArgsError struct {
	err  string
	args UpdateArguments
}

func (crdt genericCRDT) initialize() (newCrdt genericCRDT) {
	return genericCRDT{}
}

//Note that this only copies the generic part
func (crdt genericCRDT) copy() (copyCrdt genericCRDT) {
	return genericCRDT{}
}
