package crdt

import (
	"potionDB/src/clocksi"
	"fmt"
)

//TODO: Removes don't work as of now, since they make the replicas diverge.
//Likelly will need a new, better thought of, algorithm.
/*TODO: Bug that affects potencially all CRDTs: in multi-update transactions, each update doesn't
reflect the effects of the previous upds, which can lead to wrong results.
E.g: in a set with uniques, add(a) -> rem(a) in the same transaction leads to wrong result - the
unique generated by add(a) won't be removed by rem(a).
*/

const CRDTType_RRMAP CRDTType = 11
const (
	REDO                        = true
	NORMAL                      = false
	INITIAL_UPDSNOTAPPLIED_SIZE = 10 //Buffer size for updsnotapplied of each embedded CRDT
)

type RWEmbMapCrdt struct {
	*genericInversibleCRDT
	//entries RWEmbCRDT
	entries   map[string]CRDT
	removes   map[string]map[int64]int64 //replicaID -> clk value
	rmvClock  clocksi.Timestamp
	replicaID int64 //Needed for some embedded CRDTs and for rmvClock
	//Extra metadata for rebuilding old CRDT versions via inversibleCRDT.
	//Should not be copied or transmitted to other replicas
	keysToRebuild map[string]struct{} //Stores the keys of the CRDTs that were changed while going back in time
}

/*
Idea: check archive article but opt OR-Set. But the idea is that a remove increases rmvClock
and sends replicaID's clk. On add, all pairs (replicaID, clk) are sent and an add only is
successful if removes gets emptied.
*/

/*
type RWEmbCRDT struct {
	CRDT
	//ReplicaID -> clock value
	clk map[int64]int64
}
*/

//States returned by queries

type EmbMapEntryState struct {
	States map[string]State
}

type EmbMapGetValueState struct {
	State State
}

type EmbMapHasKeyState struct {
	HasKey bool
}

type EmbMapKeysState struct {
	Keys []string
}

//Uses queries defined in orMap.go

//Operations

type EmbMapUpdate struct {
	Key string
	Upd UpdateArguments
}

//TODO: Might be worth it to change this to support multiple updates per key
type EmbMapUpdateAll struct {
	Upds map[string]UpdateArguments
}

//Removes are the same as the ones used in orMap

//Downstream operations

type DownstreamRWEmbMapUpdateAll struct {
	Upds       map[string]DownstreamArguments
	RmvEntries map[int64]int64 //replicaID -> clk value
}

type DownstreamRWEmbMapRemoveAll struct {
	Rems      []string
	Ts        int64
	ReplicaID int64
}

//Operation effects for inversibleCRDT

type RWEmbMapUpdateAllEffect struct {
	Updated      []string                   //Keys for which updates were applied
	PreviousRmvs map[string]map[int64]int64 //keys for which the removeClk was deleted while applying the update
}

type RWEmbMapRemoveAllEffect struct {
	RemovedCRDTs map[string]CRDT
	ReplicaID    int64
	PreviousClk  int64 //Previous value of rmvClock[replicaID]
}

func (args EmbMapUpdate) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapUpdateAll) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args DownstreamRWEmbMapUpdateAll) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args DownstreamRWEmbMapRemoveAll) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapEntryState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapGetValueState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapHasKeyState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args EmbMapKeysState) GetCRDTType() CRDTType { return CRDTType_RRMAP }

func (args DownstreamRWEmbMapUpdateAll) MustReplicate() bool { return true }

func (args DownstreamRWEmbMapRemoveAll) MustReplicate() bool { return true }

//Note: crdt can (and most often will be) nil
func (crdt *RWEmbMapCrdt) Initialize(startTs *clocksi.Timestamp, replicaID int64) (newCrdt CRDT) {
	crdt = &RWEmbMapCrdt{
		genericInversibleCRDT: (&genericInversibleCRDT{}).initialize(startTs),
		entries:               make(map[string]CRDT),
		removes:               make(map[string]map[int64]int64),
		rmvClock:              clocksi.NewClockSiTimestamp(replicaID),
		replicaID:             replicaID,
	}
	newCrdt = crdt
	return
}

func (crdt *RWEmbMapCrdt) Read(args ReadArguments, updsNotYetApplied []UpdateArguments) (state State) {
	switch typedArg := args.(type) {
	case StateReadArguments:
		return crdt.getState(updsNotYetApplied)
	case GetKeysArguments:
		return crdt.getKeys(updsNotYetApplied)
	case GetValueArguments:
		return crdt.getValue(updsNotYetApplied, typedArg.Key)
	case HasKeyArguments:
		return crdt.hasKey(updsNotYetApplied, typedArg.Key)
	}
	return nil
}

func (crdt *RWEmbMapCrdt) getState(updsNotYetApplied []UpdateArguments) (state EmbMapEntryState) {
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			states[key] = embCrdt.Read(StateReadArguments{}, updsNotYetApplied)
		}
		return EmbMapEntryState{States: states}
	}

	/*
		Each entry may contain either:
		A) multiple updates, at most one for each CRDT;
		B) multiple removes
		Since we have multiple entries, we may also have multiple updates for a CRDT.
		Including possibly a remove in the middle of a CRDT that later gets updated...

		So, idea:
		Have a map of key -> [Updates].
		Stores updates normally.
		Use NoOp{} to signal removes (and hide all ops before).
	*/

	applyByCRDT := make(map[string][]UpdateArguments)
	for _, upds := range updsNotYetApplied {
		switch convUpds := upds.(type) {
		case EmbMapUpdate:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			applyByCRDT[convUpds.Key] = append(entry, convUpds.Upd)
		case EmbMapUpdateAll:
			for key, upd := range convUpds.Upds {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				applyByCRDT[key] = append(entry, upd)
			}
		case MapRemove:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
			applyByCRDT[convUpds.Key] = append(entry, NoOp{})
		case MapRemoveAll:
			for _, key := range convUpds.Keys {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
				applyByCRDT[key] = append(entry, NoOp{})
			}
		}
	}

	//Now, apply
	for key, upds := range applyByCRDT {
		if (upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				states[key] = InitializeCrdt(upds[1].GetCRDTType(),
					crdt.replicaID).Read(StateReadArguments{}, upds[1:])
			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, upds[0])
			states[key] = embCrdt.Read(StateReadArguments{}, upds)
		}
	}
	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getKeys(updsNotYetApplied []UpdateArguments) (state MapKeysState) {
	//Literally a copy from ORMap. Sigh
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		keys := make([]string, len(crdt.entries))
		i := 0
		for key, _ := range crdt.entries {
			keys[i] = key
			i++
		}
		return MapKeysState{Keys: keys}
	}

	adds := make(map[string]struct{})
	rems := make(map[string]struct{})

	//Key idea: for each key, the latest update is the only one that matters, hence start at the end.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := updsNotYetApplied[i].(type) {
		case EmbMapUpdate:
			if _, has := rems[typedUpd.Key]; !has {
				adds[typedUpd.Key] = struct{}{}
			}
		case MapRemove:
			if _, has := adds[typedUpd.Key]; !has {
				rems[typedUpd.Key] = struct{}{}
			}
		case EmbMapUpdateAll:
			for key, _ := range typedUpd.Upds {
				if _, has := rems[key]; !has {
					adds[key] = struct{}{}
				}
			}
		case MapRemoveAll:
			for _, key := range typedUpd.Keys {
				if _, has := adds[key]; !has {
					rems[key] = struct{}{}
				}
			}
		}
	}

	//Build state
	keys := make([]string, len(crdt.entries)+len(adds)-len(rems))
	i := 0
	for key, _ := range crdt.entries {
		if _, has := rems[key]; !has {
			keys[i] = key
			i++
		}
	}
	for key := range adds {
		if _, has := crdt.entries[key]; !has {
			keys[i] = key
			i++
		}
	}
	return MapKeysState{Keys: keys}
}

func (crdt *RWEmbMapCrdt) getValue(updsNotYetApplied []UpdateArguments, key string) (state EmbMapGetValueState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		//Return right away
		return EmbMapGetValueState{State: crdt.entries[key].Read(StateReadArguments{}, updsNotYetApplied)}
	}

	//Collect all upds for key
	keyUpds := make([]UpdateArguments, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
	for _, upd := range updsNotYetApplied {
		switch typedUpd := upd.(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				keyUpds = append(keyUpds, typedUpd.Upd)
			}
		case EmbMapUpdateAll:
			if upd, has := typedUpd.Upds[key]; has {
				keyUpds = append(keyUpds, upd)
			}
		case MapRemove:
			if key == typedUpd.Key {
				keyUpds = keyUpds[len(keyUpds):]
				keyUpds = append(keyUpds, NoOp{})
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if key == embKey {
					keyUpds = keyUpds[len(keyUpds):]
					keyUpds = append(keyUpds, NoOp{})
					break
				}
			}
		}
	}

	var embCrdt CRDT
	var has bool
	if (keyUpds[0] == NoOp{}) {
		//Reset CRDT
		if len(keyUpds) > 1 {
			embCrdt, has = InitializeCrdt(keyUpds[1].GetCRDTType(), crdt.replicaID), true
			//Hide remove
			keyUpds = keyUpds[1:]
		}
	}
	if !has {
		//Get CRDT from exiting entry
		embCrdt, has = crdt.entries[key]
		if len(keyUpds) == 0 {
			//CRDT doesn't exist and we got no way of knowing which type it was.
			return EmbMapGetValueState{State: RegisterState{Value: nil}}
		} else {
			embCrdt = InitializeCrdt(keyUpds[1].GetCRDTType(), crdt.replicaID)
		}
	}
	return EmbMapGetValueState{State: embCrdt.Read(StateReadArguments{}, keyUpds)}
}

func (crdt *RWEmbMapCrdt) hasKey(updsNotYetApplied []UpdateArguments, key string) (state MapHasKeyState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		_, has := crdt.entries[key]
		return MapHasKeyState{HasKey: has}
	}

	//Search from finish to end for the "first" op which refers to key.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := updsNotYetApplied[i].(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: true}
			}
		case EmbMapUpdateAll:
			if _, has := typedUpd.Upds[key]; has {
				return MapHasKeyState{HasKey: true}
			}
		case MapRemove:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: false}
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if embKey == key {
					return MapHasKeyState{HasKey: false}
				}
			}
		}
	}

	//No update for key, so check crdt state
	_, has := crdt.entries[key]
	return MapHasKeyState{HasKey: has}
}

//TODO: Maybe one day implement add and remove with their own methods (i.e., avoid the overhead of creating/handling arrays and maps?)
func (crdt *RWEmbMapCrdt) Update(args UpdateArguments) (downstreamArgs DownstreamArguments) {
	//fmt.Println("Updating:", args)
	switch opType := args.(type) {
	case EmbMapUpdate:
		upds := make(map[string]UpdateArguments)
		upds[opType.Key] = opType.Upd
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(upds)
	case MapRemove:
		keys := make([]string, 1)
		keys[0] = opType.Key
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(keys)
	case EmbMapUpdateAll:
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(opType.Upds)
	case MapRemoveAll:
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(opType.Keys)
	}
	return
}

func (crdt *RWEmbMapCrdt) getUpdateAllDownstreamArgs(upds map[string]UpdateArguments) (downstreamArgs DownstreamArguments) {
	downstreams := make(map[string]DownstreamArguments)
	rmvEntries := make(map[int64]int64)
	//Get downstream args and highest remove clk
	for key, upd := range upds {
		embCrdt, _ := crdt.getOrCreateEmbCrdt(key, upd)
		embUpd := embCrdt.Update(upd)
		if (embUpd != NoOp{} && embUpd.MustReplicate()) {
			downstreams[key] = embUpd
		}
		rmvClk, has := crdt.removes[key]
		if has {
			for replica, clk := range rmvClk {
				existingClk := rmvEntries[replica]
				if clk > existingClk {
					rmvEntries[replica] = clk
				}
			}
		}
	}

	//May happen due to NuCRDTs. In this case, there's no need to downstream
	if len(downstreams) == 0 && len(rmvEntries) == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapUpdateAll{Upds: downstreams, RmvEntries: rmvEntries}
}

func (crdt *RWEmbMapCrdt) getRemoveAllDownstreamArgs(keys []string) (downstreamArgs DownstreamArguments) {
	toRemove := make([]string, len(keys))
	i := 0
	for _, key := range keys {
		if _, has := crdt.entries[key]; has {
			toRemove[i] = key
			i++
		}
	}
	//No CRDT to remove, so an empty op will do
	if i == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapRemoveAll{Rems: toRemove[:i], ReplicaID: crdt.replicaID, Ts: crdt.rmvClock.GetPos(crdt.replicaID) + 1}
}

func (crdt *RWEmbMapCrdt) Downstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments) (otherDownstreamArgs DownstreamArguments) {
	//fmt.Println("Downstreaming:", downstreamArgs)
	//When applying downstreams in the emb CRDTs, new ops may be returned from a NuCRDT
	effect, otherDownstreamArgs := crdt.applyDownstream(updTs, downstreamArgs, NORMAL)
	//Necessary for inversibleCrdt
	crdt.addToHistory(&updTs, &downstreamArgs, effect)
	return
}

//Note: When reapplying ops, we need to ensure that we don't replay downstreams in the embedded CRDTs
//Hence the use of the boolean
func (crdt *RWEmbMapCrdt) applyDownstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments, isRedo bool) (effect *Effect,
	otherDownstreamArgs DownstreamArguments) {
	var tmpEffect Effect = NoEffect{}
	switch opType := downstreamArgs.(type) {
	case DownstreamRWEmbMapUpdateAll:
		tmpEffect, otherDownstreamArgs = crdt.applyUpdateAll(updTs, opType.Upds, opType.RmvEntries, isRedo)
	case DownstreamRWEmbMapRemoveAll:
		tmpEffect = crdt.applyRemoveAll(opType.Rems, opType.ReplicaID, opType.Ts)
	}
	return &tmpEffect, otherDownstreamArgs
}

//Note: Assumes that all updates are for the correct embedded CRDT type
func (crdt *RWEmbMapCrdt) applyUpdateAll(updTs clocksi.Timestamp, upds map[string]DownstreamArguments,
	remClks map[int64]int64, isRedo bool) (effect *RWEmbMapUpdateAllEffect, otherDownstreamArgs DownstreamArguments) {
	effect = &RWEmbMapUpdateAllEffect{Updated: make([]string, len(upds)), PreviousRmvs: make(map[string]map[int64]int64)}
	newDown := make(map[string]DownstreamArguments) //emb NuCRDTs may generate new downstreams
	updatedIndex := 0

	for key, upd := range upds {
		remEntry, has := crdt.removes[key]
		canAdd := !has
		//Remove-wins policy, this add can only have effect if it surparsses all removes.
		if has {
			for replica, clk := range remEntry {
				if remValue, has := remClks[replica]; !has || clk > remValue {
					//Can't apply this update, check next CRDT/upd
					break	//Leaves canAdd as false
				}
			}
			if canAdd {
				//Add is after update
				effect.PreviousRmvs[key] = crdt.removes[key]
				delete(crdt.removes, key)
				has = false
			}
		} else {
			//Only CRDTs that weren't "previously deleted" should be marked as updated in the effect
			effect.Updated[updatedIndex] = key
			updatedIndex++
		}
		if !isRedo && canAdd {
			//Either there was no remove or this add is after all other known removes.
			embCRDT, new := crdt.getOrCreateEmbCrdt(key, upd)
			embDownstream := embCRDT.Downstream(updTs, upd)
			if new {
				//fmt.Println("Storing new emb CRDT")
				crdt.entries[key] = embCRDT
			}
			if embDownstream != nil {
				fmt.Println("Embedded generated new downstreams")
				newDown[key] = embDownstream
			}
		}
	}

	effect.Updated = effect.Updated[:updatedIndex]
	if len(newDown) == 0 {
		return effect, nil
	}
	fmt.Println("Got new downstreams!")
	return effect, DownstreamRWEmbMapUpdateAll{Upds: newDown, RmvEntries: make(map[int64]int64)}
}

func (crdt *RWEmbMapCrdt) applyRemoveAll(toRem []string, remoteReplicaID int64, remoteClk int64) (effect *RWEmbMapRemoveAllEffect) {
	effect = &RWEmbMapRemoveAllEffect{
		PreviousClk:  crdt.rmvClock.GetPos(remoteReplicaID),
		ReplicaID:    remoteReplicaID,
		RemovedCRDTs: make(map[string]CRDT),
	}
	crdt.rmvClock.UpdatePos(remoteReplicaID, remoteClk)
	for _, key := range toRem {
		existingCRDT, has := crdt.entries[key]
		if has {
			effect.RemovedCRDTs[key] = existingCRDT
			delete(crdt.entries, key)
		}
		remEntry, has := crdt.removes[key]
		if !has {
			remEntry = make(map[int64]int64)
			crdt.removes[key] = remEntry
		}
		remEntry[remoteReplicaID] = remoteClk
	}
	return
}

func (crdt *RWEmbMapCrdt) IsOperationWellTyped(args UpdateArguments) (ok bool, err error) {
	//TODO: Typechecking
	return true, nil
}

//METHODS FOR INVERSIBLE_CRDT

func (crdt *RWEmbMapCrdt) Copy() (copyCRDT InversibleCRDT) {
	newCrdt := RWEmbMapCrdt{
		genericInversibleCRDT: crdt.genericInversibleCRDT.copy(),
		entries:               make(map[string]CRDT),
		removes:               make(map[string]map[int64]int64),
		rmvClock:              crdt.rmvClock.Copy(),
		replicaID:             crdt.replicaID,
	}
	for key, embCrdt := range crdt.entries {
		newCrdt.entries[key] = embCrdt.(InversibleCRDT).Copy()
	}
	for key, rmvMap := range crdt.removes {
		newMap := make(map[int64]int64)
		for replica, value := range rmvMap {
			newMap[replica] = value
		}
		newCrdt.removes[key] = newMap
	}

	return &newCrdt
}

func (crdt *RWEmbMapCrdt) RebuildCRDTToVersion(targetTs clocksi.Timestamp) {
	//We'll keep a log of the CRDTs that need to be rebuilt, for efficiency.
	//There's also an opportunity to do so here with multiple goroutines, but that wouldn't be complete
	//and would recalculate old states of CRDTs that were deleted in the past and thus unecessary.
	crdt.keysToRebuild = make(map[string]struct{})
	crdt.genericInversibleCRDT.rebuildCRDTToVersion(targetTs, crdt.undoEffect, crdt.reapplyOp, crdt.notifyRebuiltComplete)
}

func (crdt *RWEmbMapCrdt) reapplyOp(updArgs DownstreamArguments) (effect *Effect) {
	//The timestamp (nil) is only used by embedded CRDTs, which won't be changed now due to the REDO flag.
	effect, _ = crdt.applyDownstream(nil, updArgs, REDO)
	return effect
}

func (crdt *RWEmbMapCrdt) undoEffect(effect *Effect) {
	switch typedEffect := (*effect).(type) {
	case RWEmbMapUpdateAllEffect:
		crdt.undoUpdateAllEffect(typedEffect.Updated, typedEffect.PreviousRmvs)
	case RWEmbMapRemoveAllEffect:
		crdt.undoRemoveAllEffect(typedEffect.RemovedCRDTs, typedEffect.ReplicaID, typedEffect.PreviousClk)
	}
}

func (crdt *RWEmbMapCrdt) undoUpdateAllEffect(updated []string, previousRems map[string]map[int64]int64) {
	//CRDTs that were as removed before this add
	for key, previousClk := range previousRems {
		crdt.removes[key] = previousClk //Should be safe as this is a CRDT copy that won't be changed
		delete(crdt.entries, key)
		delete(crdt.keysToRebuild, key)
	}
	//CRDTs that were updated. Mark them as needed to be updated later
	for _, key := range updated {
		crdt.keysToRebuild[key] = struct{}{}
	}
}

func (crdt *RWEmbMapCrdt) undoRemoveAllEffect(removedCRDTs map[string]CRDT, replicaID int64, previousClk int64) {
	//CRDTs that were removed by this remove. We need to add them back
	for key, embCrdt := range removedCRDTs {
		crdt.entries[key] = embCrdt
		delete(crdt.removes, key)
	}
	crdt.rmvClock.UpdateForcedPos(replicaID, previousClk)
}
func (crdt *RWEmbMapCrdt) notifyRebuiltComplete(currTs *clocksi.Timestamp) {
	//Only redo CRDTs that were altered
	for key := range crdt.keysToRebuild {
		crdt.entries[key].(InversibleCRDT).RebuildCRDTToVersion(*currTs)
	}
	crdt.keysToRebuild = nil
}

//Others

func (crdt *RWEmbMapCrdt) getOrCreateEmbCrdt(key string, upd UpdateArguments) (embCrdt CRDT, new bool) {
	embCrdt, has := crdt.entries[key]
	new = !has
	if !has {
		embCrdt = InitializeCrdt(upd.GetCRDTType(), crdt.replicaID)
	}
	return
}
