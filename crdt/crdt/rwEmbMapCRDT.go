package crdt

import (
	"fmt"
	"strings"

	"potionDB/crdt/clocksi"
	"potionDB/crdt/proto"

	//pb "github.com/golang/protobuf/proto"
	pb "google.golang.org/protobuf/proto"
)

/*TODO: Bug that affects potencially all CRDTs: in multi-update transactions, each update doesn't
reflect the effects of the previous upds, which can lead to wrong results.
E.g: in a set with uniques, add(a) -> rem(a) in the same transaction leads to wrong result - the
unique generated by add(a) won't be removed by rem(a).
*/

//Note: This CRDT is optimized for adds - this assumes that removes are a rarity.
//TODO: Undos
//TODO: Re-enable marks?

const (
	REDO                        = true
	NORMAL                      = false
	INITIAL_UPDSNOTAPPLIED_SIZE = 10 //Buffer size for updsnotapplied of each embedded CRDT
)

type RWEmbMapCrdt struct {
	CRDTVM
	//entries RWEmbCRDT
	entries   map[string]CRDT
	removes   map[string]map[int16]*markedTimestamp //replicaID -> (clk value, mark)
	rmvClock  clocksi.Timestamp
	replicaID int16 //Needed for some embedded CRDTs and for rmvClock
	//Extra metadata for rebuilding old CRDT versions via inversibleCRDT.
	//Should not be copied or transmitted to other replicas
	keysToRebuild map[string]struct{} //Stores the keys of the CRDTs that were changed while going back in time
}

type markedTimestamp struct {
	ts   int64
	mark bool
}

/*
Idea: check archive article but opt OR-Set. But the idea is that a remove increases rmvClock
and sends replicaID's clk. On add, all pairs (replicaID, clk) are sent and an add only is
successful if removes gets emptied.
*/

/*
type RWEmbCRDT struct {
	CRDT
	//ReplicaID -> clock value
	clk map[int64]int64
}
*/

//States returned by queries

type EmbMapEntryState struct {
	States map[string]State
}

type EmbMapGetValueState struct {
	State State
}

type EmbMapHasKeyState struct {
	HasKey bool
}

type EmbMapKeysState struct {
	Keys []string
}

type EmbMapGetValuesState struct {
	States map[string]State
}

// Also uses queries defined in orMap.go
type EmbMapGetValueArguments struct {
	Key  string
	Args ReadArguments
}

type EmbMapPartialArguments struct {
	Args map[string]ReadArguments
}

// Applies the same ReadArguments to all keys in the map.
// Useful for embedded maps inside of embedded maps.
type EmbMapPartialOnAllArguments struct {
	ArgForAll ReadArguments
}

type EmbMapExceptArguments struct {
	ExceptKeys map[string]struct{}
	ArgForAll  ReadArguments //Optional, can be full read
}

type CompType byte

const (
	EQ, NEQ, LEQ, L, H, HEQ = CompType(1), CompType(0), CompType(2), CompType(3), CompType(4), CompType(5)
)

type CompareArguments interface {
	GetCompType() CompType
}

type IntCompareArguments struct {
	Value int64
	CompType
}

type FloatCompareArguments struct {
	Value float64
	CompType
}

type StringCompareArguments struct {
	Value       string
	IsEqualComp bool
}

type BytesCompareArguments struct {
	Value       []byte
	IsEqualComp bool
}

type BoolCompareArguments struct {
	Value       bool
	IsEqualComp bool
}

type GetNoCompareArguments struct{}

type MapCompareArguments struct {
	MapArgs map[string]CompareArguments
}

type EmbMapConditionalReadArguments struct {
	CondArgs map[string]CompareArguments
}

type EmbMapConditionalReadAllArguments struct {
	CompareArguments
}

// When we want to filter certain keys and test every other key for a condition
type EmbMapConditionalReadExceptArguments struct {
	ExceptKeys    map[string]struct{}
	CondArgForAll CompareArguments
}

//Operations

type EmbMapUpdate struct {
	Key string
	Upd UpdateArguments
}

// TODO: Might be worth it to change this to support multiple updates per key
type EmbMapUpdateAll struct {
	Upds map[string]UpdateArguments
}

// May be considerably more efficient for maps with many entries
type EmbMapUpdateAllArray struct {
	Upds []EmbMapUpdate //Pair of Key, Upd
}

//Removes are the same as the ones used in orMap

//Downstream operations

type DownstreamRWEmbMapUpdateAll struct {
	Upds       map[string]DownstreamArguments
	RmvEntries map[int16]int64 //replicaID -> clk value
	ReplicaID  int16
}

type DownstreamRWEmbMapRemoveAll struct {
	Rems      []string
	Ts        int64
	ReplicaID int16
}

type DownstreamRWEmbMapUpdateAllArray struct {
	Upds       []KeyDownArgsPair
	RmvEntries map[int16]int64 //replicaID -> clk value
	ReplicaID  int16
}

type KeyDownArgsPair struct {
	Key string
	Upd DownstreamArguments
}

//Operation effects for inversibleCRDT

// Add if mark was there or not for the replica. Also need to add the replicaID.
type RWEmbMapUpdateAllEffect struct {
	Updated        []string //Keys for which updates were applied
	ReplicaID      int16
	AddedMark      map[string]struct{}
	PreviousRmvClk map[string]map[int16]*markedTimestamp
}

// Can use previousClk to know if an entry was added to RmvEntries (if previousClk == 0, then a new entry was added)
type RWEmbMapRemoveAllEffect struct {
	RemovedCRDTs map[string]CRDT
	ReplicaID    int16
	PreviousClk  int64 //Previous value of rmvClock[replicaID]
}

func (compArgs *GetNoCompareArguments) GetCompType() CompType { return EQ }
func (compArgs *IntCompareArguments) GetCompType() CompType   { return compArgs.CompType }
func (compArgs *FloatCompareArguments) GetCompType() CompType { return compArgs.CompType }
func (compArgs *MapCompareArguments) GetCompType() CompType   { return EQ }
func (compArgs *StringCompareArguments) GetCompType() CompType {
	if compArgs.IsEqualComp {
		return EQ
	}
	return NEQ
}
func (compArgs *BytesCompareArguments) GetCompType() CompType {
	if compArgs.IsEqualComp {
		return EQ
	}
	return NEQ
}
func (compArgs *BoolCompareArguments) GetCompType() CompType {
	if compArgs.IsEqualComp {
		return EQ
	}
	return NEQ
}

func (crdt *RWEmbMapCrdt) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

// Upds
func (args EmbMapUpdate) GetCRDTType() proto.CRDTType         { return proto.CRDTType_RRMAP }
func (args EmbMapUpdateAll) GetCRDTType() proto.CRDTType      { return proto.CRDTType_RRMAP }
func (args EmbMapUpdateAllArray) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }

// Downstreams
func (args DownstreamRWEmbMapUpdateAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }
func (args DownstreamRWEmbMapRemoveAll) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }
func (args DownstreamRWEmbMapUpdateAll) MustReplicate() bool         { return true }
func (args DownstreamRWEmbMapRemoveAll) MustReplicate() bool         { return true }
func (args DownstreamRWEmbMapUpdateAllArray) GetCRDTType() proto.CRDTType {
	return proto.CRDTType_RRMAP
}
func (args DownstreamRWEmbMapUpdateAllArray) MustReplicate() bool { return true }

// States
func (args EmbMapEntryState) GetCRDTType() proto.CRDTType     { return proto.CRDTType_RRMAP }
func (args EmbMapEntryState) GetREADType() proto.READType     { return proto.READType_FULL }
func (args EmbMapGetValueState) GetCRDTType() proto.CRDTType  { return proto.CRDTType_RRMAP }
func (args EmbMapGetValueState) GetREADType() proto.READType  { return proto.READType_GET_VALUE }
func (args EmbMapHasKeyState) GetCRDTType() proto.CRDTType    { return proto.CRDTType_RRMAP }
func (args EmbMapHasKeyState) GetREADType() proto.READType    { return proto.READType_HAS_KEY }
func (args EmbMapKeysState) GetCRDTType() proto.CRDTType      { return proto.CRDTType_RRMAP }
func (args EmbMapKeysState) GetREADType() proto.READType      { return proto.READType_GET_KEYS }
func (args EmbMapGetValuesState) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }
func (args EmbMapGetValuesState) GetREADType() proto.READType { return proto.READType_GET_VALUES }

// Queries
func (args EmbMapGetValueArguments) GetCRDTType() proto.CRDTType     { return proto.CRDTType_RRMAP }
func (args EmbMapGetValueArguments) GetREADType() proto.READType     { return proto.READType_GET_VALUE }
func (args EmbMapPartialArguments) GetCRDTType() proto.CRDTType      { return proto.CRDTType_RRMAP }
func (args EmbMapPartialArguments) GetREADType() proto.READType      { return proto.READType_GET_VALUES }
func (args EmbMapPartialOnAllArguments) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }
func (args EmbMapPartialOnAllArguments) GetREADType() proto.READType {
	return proto.READType_GET_ALL_VALUES
}
func (args EmbMapConditionalReadArguments) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }
func (args EmbMapConditionalReadArguments) GetREADType() proto.READType {
	return proto.READType_GET_COND
}
func (args EmbMapConditionalReadAllArguments) GetCRDTType() proto.CRDTType {
	return proto.CRDTType_RRMAP
}
func (args EmbMapConditionalReadAllArguments) GetREADType() proto.READType {
	return proto.READType_GET_ALL_COND
}
func (args EmbMapConditionalReadExceptArguments) GetCRDTType() proto.CRDTType {
	return proto.CRDTType_RRMAP
}
func (args EmbMapConditionalReadExceptArguments) GetREADType() proto.READType {
	return proto.READType_GET_EXCEPT_COND
}

func (args EmbMapExceptArguments) GetCRDTType() proto.CRDTType { return proto.CRDTType_RRMAP }
func (args EmbMapExceptArguments) GetREADType() proto.READType { return proto.READType_GET_EXCEPT }

// Note: crdt can (and most often will be) nil
func (crdt *RWEmbMapCrdt) Initialize(startTs *clocksi.Timestamp, replicaID int16) (newCrdt CRDT) {
	crdt = &RWEmbMapCrdt{
		CRDTVM:   (&genericInversibleCRDT{}).initialize(startTs, crdt.undoEffect, crdt.reapplyOp, crdt.notifyRebuiltComplete),
		entries:  make(map[string]CRDT),
		removes:  make(map[string]map[int16]*markedTimestamp),
		rmvClock: clocksi.NewClockSiTimestamp(),
		//rmvClock:              clocksi.NewClockSiTimestamp(replicaID),
		replicaID: replicaID,
	}
	newCrdt = crdt
	return
}

// Used to initialize when building a CRDT from a remote snapshot
func (crdt *RWEmbMapCrdt) initializeFromSnapshot(startTs *clocksi.Timestamp, replicaID int16) (sameCRDT *RWEmbMapCrdt) {
	crdt.CRDTVM, crdt.replicaID = (&genericInversibleCRDT{}).initialize(startTs, crdt.undoEffect, crdt.reapplyOp, crdt.notifyRebuiltComplete), replicaID
	return crdt
}

func (crdt *RWEmbMapCrdt) Read(args ReadArguments, updsNotYetApplied []UpdateArguments) (state State) {
	//fmt.Printf("[RWEmb][Read]Read args: %+v (%T)\n", args, args)
	switch typedArg := args.(type) {
	case StateReadArguments:
		return crdt.getState(updsNotYetApplied)
	case GetKeysArguments:
		return crdt.getKeys(updsNotYetApplied)
	case EmbMapGetValueArguments:
		return crdt.getValue(updsNotYetApplied, typedArg.Key, typedArg.Args)
	case HasKeyArguments:
		return crdt.hasKey(updsNotYetApplied, typedArg.Key)
	case GetValuesArguments:
		return crdt.getValues(updsNotYetApplied, typedArg.Keys)
	case EmbMapPartialArguments:
		return crdt.getPartialState(updsNotYetApplied, typedArg.Args)
	case EmbMapPartialOnAllArguments:
		return crdt.getAllPartialState(updsNotYetApplied, typedArg.ArgForAll)
	case EmbMapConditionalReadArguments:
		return crdt.getCondState(updsNotYetApplied, typedArg.CondArgs)
	case EmbMapConditionalReadAllArguments:
		return crdt.getAllCondState(updsNotYetApplied, typedArg.CompareArguments)
	case EmbMapExceptArguments:
		return crdt.getAllExcept(updsNotYetApplied, typedArg.ExceptKeys, typedArg.ArgForAll)
	case EmbMapConditionalReadExceptArguments:
		return crdt.getExceptCondState(updsNotYetApplied, typedArg.ExceptKeys, typedArg.CondArgForAll)
	default:
		fmt.Printf("[RWEmb]Unknown read type: %T\n", args)
	}
	return nil
}

func (crdt *RWEmbMapCrdt) getState(updsNotYetApplied []UpdateArguments) (state EmbMapEntryState) {
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			states[key] = embCrdt.Read(StateReadArguments{}, updsNotYetApplied)
		}
		return EmbMapEntryState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	//Now, apply
	for key, upds := range applyByCRDT {
		if (upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				states[key] = InitializeCrdt((upds[1]).GetCRDTType(),
					crdt.replicaID).Read(StateReadArguments{}, upds[1:])
			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
			states[key] = embCrdt.Read(StateReadArguments{}, upds)
		}
	}

	//Also need to include CRDTs that aren't referred in applyByCRDT
	for key, embCrdt := range crdt.entries {
		if _, has := applyByCRDT[key]; !has {
			states[key] = embCrdt.Read(StateReadArguments{}, []UpdateArguments{})
		}
	}
	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) prepareApplyByCRDTMap(updsNotYetApplied []UpdateArguments) (applyByCRDT map[string][]UpdateArguments) {
	/*
		Each entry may contain either:
		A) multiple updates, at most one for each CRDT;
		B) multiple removes
		Since we have multiple entries, we may also have multiple updates for a CRDT.
		Including possibly a remove in the middle of a CRDT that later gets updated...

		So, idea:
		Have a map of key -> [Updates].
		Stores updates normally.
		Use NoOp{} to signal removes (and hide all ops before).
	*/
	applyByCRDT = make(map[string][]UpdateArguments)
	var noOp UpdateArguments = NoOp{}
	for _, upds := range updsNotYetApplied {
		switch convUpds := (upds).(type) {
		case EmbMapUpdate:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			applyByCRDT[convUpds.Key] = append(entry, convUpds.Upd)
		case EmbMapUpdateAll:
			for key, upd := range convUpds.Upds {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				applyByCRDT[key] = append(entry, upd)
			}
		case EmbMapUpdateAllArray:
			for _, upd := range convUpds.Upds {
				entry, has := applyByCRDT[upd.Key]
				if !has {
					entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				applyByCRDT[upd.Key] = append(entry, upd)
			}
		case MapRemove:
			entry, has := applyByCRDT[convUpds.Key]
			if !has {
				entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
			}
			entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
			applyByCRDT[convUpds.Key] = append(entry, noOp)
		case MapRemoveAll:
			for _, key := range convUpds.Keys {
				entry, has := applyByCRDT[key]
				if !has {
					entry = make([]UpdateArguments, 0, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
				}
				entry = entry[len(entry):] //Hiding all previous upds which are now irrelevant
				applyByCRDT[key] = append(entry, noOp)
			}
		}
	}
	return applyByCRDT
}

func (crdt *RWEmbMapCrdt) getAllPartialState(updsNotYetApplied []UpdateArguments, arg ReadArguments) (state EmbMapGetValuesState) {
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			states[key] = embCrdt.Read(arg, updsNotYetApplied)
			//fmt.Printf("[RWEmb][GetAllPartial]Key: %v. Value: %+v\n", key, states[key])
		}
		return EmbMapGetValuesState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	//Now, apply
	for key, upds := range applyByCRDT {
		if (upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				states[key] = InitializeCrdt((upds[1]).GetCRDTType(),
					crdt.replicaID).Read(arg, upds[1:])
			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
			states[key] = embCrdt.Read(arg, upds)
		}
	}

	//Also need to include CRDTs that aren't referred in applyByCRDT
	for key, embCrdt := range crdt.entries {
		if _, has := applyByCRDT[key]; !has {
			states[key] = embCrdt.Read(arg, []UpdateArguments{})
		}
	}
	return EmbMapGetValuesState{States: states}

}

func (crdt *RWEmbMapCrdt) getExceptCondState(updsNotYetApplied []UpdateArguments, exceptKeys map[string]struct{}, condArgs CompareArguments) (state EmbMapEntryState) {
	//Similar to getCondState but without filtering keys
	//fmt.Printf("[RWEmbMap][GetAllCondState]CompareArguments: %+v\n", condArgs)
	states := make(map[string]State)
	var currState State
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			if _, has := exceptKeys[key]; !has {
				currState = crdt.getStateIfCondition(embCrdt, updsNotYetApplied, condArgs)
				if currState != nil {
					states[key] = currState
				}
			}
		}
		return EmbMapEntryState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	//Now, apply
	for key, upds := range applyByCRDT {
		if _, has := exceptKeys[key]; has {
			continue //Skip
		}
		if (upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				currState = crdt.getStateIfCondition(InitializeCrdt((upds[1]).GetCRDTType(),
					crdt.replicaID), upds[1:], condArgs)
				if currState != nil {
					states[key] = currState
				}
			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
			currState = crdt.getStateIfCondition(embCrdt, upds, condArgs)
			if currState != nil {
				states[key] = currState
			}
		}
	}

	//Also need to include CRDTs that aren't referred in applyByCRDT
	for key, embCrdt := range crdt.entries {
		if _, has := applyByCRDT[key]; !has {
			if _, has := exceptKeys[key]; !has {
				currState = crdt.getStateIfCondition(embCrdt, []UpdateArguments{}, condArgs)
				if currState != nil {
					states[key] = currState
				}
			}
		}
	}
	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getAllCondState(updsNotYetApplied []UpdateArguments, condArgs CompareArguments) (state EmbMapEntryState) {
	//Similar to getCondState but without filtering keys
	//fmt.Printf("[RWEmbMap][GetAllCondState]CompareArguments: %+v\n", condArgs)
	states := make(map[string]State)
	var currState State
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			currState = crdt.getStateIfCondition(embCrdt, updsNotYetApplied, condArgs)
			if currState != nil {
				states[key] = currState
			}
		}
		return EmbMapEntryState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	//Now, apply
	for key, upds := range applyByCRDT {
		if (upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				currState = crdt.getStateIfCondition(InitializeCrdt((upds[1]).GetCRDTType(),
					crdt.replicaID), upds[1:], condArgs)
				if currState != nil {
					states[key] = currState
				}
			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
			currState = crdt.getStateIfCondition(embCrdt, upds, condArgs)
			if currState != nil {
				states[key] = currState
			}
		}
	}

	//Also need to include CRDTs that aren't referred in applyByCRDT
	for key, embCrdt := range crdt.entries {
		if _, has := applyByCRDT[key]; !has {
			currState = crdt.getStateIfCondition(embCrdt, []UpdateArguments{}, condArgs)
			if currState != nil {
				states[key] = currState
			}
		}
	}
	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getCondState(updsNotYetApplied []UpdateArguments, condArgs map[string]CompareArguments) (state EmbMapEntryState) {
	//Similar to getState
	states := make(map[string]State)
	var currState State
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, args := range condArgs {
			if embCrdt, has := crdt.entries[key]; has {
				currState = crdt.getStateIfCondition(embCrdt, updsNotYetApplied, args)
				if currState != nil {
					states[key] = currState
				}
			}
		}
		return EmbMapEntryState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	for key, args := range condArgs {
		if upds, has := applyByCRDT[key]; has {
			if (upds[0] == NoOp{}) {
				if len(upds) > 1 {
					//Start from scratch
					currState = crdt.getStateIfCondition(InitializeCrdt((upds[1]).GetCRDTType(),
						crdt.replicaID), upds[1:], args)
					if currState != nil {
						states[key] = currState
					}
				} else {
					//Removed CRDT, thus doesn't belong to state
					continue
				}
			} else {
				embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
				currState = crdt.getStateIfCondition(embCrdt, upds, args)
				if currState != nil {
					states[key] = currState
				}
			}
		} else if embCrdt, has := crdt.entries[key]; has {
			currState = crdt.getStateIfCondition(embCrdt, []UpdateArguments{}, args)
			if currState != nil {
				states[key] = currState
			}
		}
	}

	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getStateIfCondition(inCrdt CRDT, upds []UpdateArguments, compArgs CompareArguments) (state State) {
	if _, ok := compArgs.(*GetNoCompareArguments); ok {
		return inCrdt.Read(StateReadArguments{}, upds)
	}
	//If the type of CRDT doesn't match, do not return the state
	crdtType := inCrdt.GetCRDTType()
	//fmt.Printf("[RWEmbMap][GetStateIfCondition]Got compArgs %+v (type %T) and CRDTType is %v\n", compArgs, compArgs, crdtType)
	switch compArgs.(type) {
	case *IntCompareArguments:
		if !(crdtType == proto.CRDTType_COUNTER || crdtType == proto.CRDTType_MAXMIN) {
			//fmt.Println("[RWEmbMap][GetStateIfCondition]Is IntCompareArguments but can't apply as CRDTType is", crdtType)
			return
		}
	case *FloatCompareArguments:
		if !(crdtType == proto.CRDTType_AVG || crdtType == proto.CRDTType_COUNTER_FLOAT) {
			return
		}
	case *MapCompareArguments:
		if crdtType != proto.CRDTType_RRMAP {
			//fmt.Println("[RWEmbMap][GetStateIfCondition]Is MapCompareArguments but can't apply as CRDTType is", crdtType)
			return
		}
	case *StringCompareArguments, *BytesCompareArguments: //Register
		if crdtType != proto.CRDTType_LWWREG {
			return
		}
	case *BoolCompareArguments: //Flag
		if !(crdtType == proto.CRDTType_FLAG_LWW || crdtType == proto.CRDTType_FLAG_EW || crdtType == proto.CRDTType_FLAG_DW) {
			return
		}
	}

	var tmpState State
	if crdtType != proto.CRDTType_RRMAP {
		tmpState = inCrdt.Read(StateReadArguments{}, upds)
	}
	switch typedArgs := compArgs.(type) {
	case *IntCompareArguments: //Must be a counter or maxmin
		var crdtValue int64
		if crdtType == proto.CRDTType_COUNTER {
			crdtValue = int64(tmpState.(CounterState).Value)
		} else {
			crdtValue = tmpState.(MaxMinState).Value
		}
		switch typedArgs.CompType {
		case EQ:
			//fmt.Printf("[RWEmbMap][GetStateIfCondition]Equal comparison in IntCompare. CrdtValue: %d. CompareToValue: %d. %d = %d\n",
			//crdtValue, typedArgs.Value, crdtValue, typedArgs.Value)
			if crdtValue == typedArgs.Value {
				return tmpState
			}
		case NEQ:
			if crdtValue != typedArgs.Value {
				return tmpState
			}
		case LEQ:
			if crdtValue <= typedArgs.Value {
				return tmpState
			}
		case L:
			if crdtValue < typedArgs.Value {
				return tmpState
			}
		case H:
			//fmt.Printf("[RWEmbMap][GetStateIfCondition]Higher comparison in IntCompare. CrdtValue: %d. CompareToValue: %d. %d > %d\n",
			//crdtValue, typedArgs.Value, crdtValue, typedArgs.Value)
			if crdtValue > typedArgs.Value {
				//fmt.Printf("[RWEmbMap][GetStateIfCondition]Returning state as %d > %d\nState: %+v\n", crdtValue, typedArgs.Value, tmpState)
				return tmpState
			}
		case HEQ:
			if crdtValue >= typedArgs.Value {
				return tmpState
			}
		}
	case *FloatCompareArguments: //Average
		var crdtValue float64
		if crdtType == proto.CRDTType_COUNTER_FLOAT {
			crdtValue = tmpState.(CounterFloatState).Value
		} else {
			crdtValue = tmpState.(AvgState).Value
		}
		switch typedArgs.CompType {
		case EQ:
			if crdtValue == typedArgs.Value {
				return tmpState
			}
		case NEQ:
			if crdtValue != typedArgs.Value {
				return tmpState
			}
		case LEQ:
			if crdtValue <= typedArgs.Value {
				return tmpState
			}
		case L:
			if crdtValue < typedArgs.Value {
				return tmpState
			}
		case H:
			if crdtValue > typedArgs.Value {
				return tmpState
			}
		case HEQ:
			if crdtValue >= typedArgs.Value {
				return tmpState
			}
		}
	case *MapCompareArguments: //Assumed to be embedded map
		//fullState := inCrdt.Read(StateReadArguments{}, upds)
		//fmt.Printf("[RWEmbMap][GetStateIfCondition]Is MapCompareArguments (%+v) and CRDTType is %v. Can apply. Full state is: %+v\n", compArgs, crdtType, fullState)
		innerMapState := inCrdt.Read(EmbMapConditionalReadArguments{CondArgs: typedArgs.MapArgs}, upds).(EmbMapEntryState)
		if len(innerMapState.States) == len(typedArgs.MapArgs) {
			//fmt.Printf("[RWEmbMap][GetStateIfCondition]Returning state after MapCompareArguments. State: %+v\n", innerMapState)
			return innerMapState
		} else {
			//fmt.Printf("[RWEmbMap][GetStateIfCondition]Not returning state after MapCompareArguments!\n Number of states: %d. Number of arguments: %d. State read: %+v\n",
			//len(innerMapState.States), len(typedArgs.MapArgs), innerMapState)
		}
	case *StringCompareArguments: //Register
		crdtValue := tmpState.(RegisterState).Value.(string)
		if (typedArgs.IsEqualComp && crdtValue == typedArgs.Value) || (!typedArgs.IsEqualComp && crdtValue != typedArgs.Value) {
			return tmpState
		}
	case *BytesCompareArguments: //Register
		crdtValue := tmpState.(RegisterState).Value.([]byte)
		if typedArgs.IsEqualComp {
			if len(crdtValue) == len(typedArgs.Value) {
				for i, dataByte := range crdtValue {
					if dataByte != typedArgs.Value[i] {
						return nil
					}
				}
				return tmpState
			}
		}
	case *BoolCompareArguments: //Flag
		crdtValue := tmpState.(FlagState).Flag
		if (typedArgs.IsEqualComp && crdtValue == typedArgs.Value) || (!typedArgs.IsEqualComp && crdtValue != typedArgs.Value) {
			return tmpState
		}
	default:
		fmt.Printf("[RWEmbMap][GetStateIfCondition]Unknown condition type %+v (type %T)\n", compArgs, compArgs)
	}
	return nil
}

func (crdt *RWEmbMapCrdt) getValues(updsNotYetApplied []UpdateArguments, keys []string) (state EmbMapEntryState) {
	//Similar to getState
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for _, key := range keys {
			if embCrdt, has := crdt.entries[key]; has {
				states[key] = embCrdt.Read(StateReadArguments{}, updsNotYetApplied)
			}
		}
		return EmbMapEntryState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	for _, key := range keys {
		if upds, has := applyByCRDT[key]; has {
			if (upds[0] == NoOp{}) {
				if len(upds) > 1 {
					//Start from scratch
					states[key] = InitializeCrdt((upds[1]).GetCRDTType(),
						crdt.replicaID).Read(StateReadArguments{}, upds[1:])
				} else {
					//Removed CRDT, thus doesn't belong to state
					continue
				}
			} else {
				embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
				states[key] = embCrdt.Read(StateReadArguments{}, upds)
			}
		} else if embCrdt, has := crdt.entries[key]; has {
			states[key] = embCrdt.Read(StateReadArguments{}, []UpdateArguments{})
		}
	}

	return EmbMapEntryState{States: states}
}

func (crdt *RWEmbMapCrdt) getAllExcept(updsNotYetApplied []UpdateArguments, exceptKeys map[string]struct{}, argForAll ReadArguments) (state EmbMapGetValuesState) {
	//Similar to getState
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, embCrdt := range crdt.entries {
			if _, has := exceptKeys[key]; !has {
				states[key] = embCrdt.Read(argForAll, updsNotYetApplied)
			}
		}
		return EmbMapGetValuesState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	for key, upds := range applyByCRDT {
		if _, has := exceptKeys[key]; has {
			continue //Skip
		}
		if (upds[0] == NoOp{}) {
			if len(upds) > 1 {
				//Start from scratch
				states[key] = InitializeCrdt((upds[1]).GetCRDTType(),
					crdt.replicaID).Read(argForAll, upds[1:])

			} else {
				//Removed CRDT, thus doesn't belong to state
				continue
			}
		} else {
			embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
			states[key] = embCrdt.Read(argForAll, upds)
		}
	}

	//Also need to include CRDTs that aren't referred in applyByCRDT
	for key, embCrdt := range crdt.entries {
		if _, has := applyByCRDT[key]; !has {
			if _, has := exceptKeys[key]; !has {
				states[key] = embCrdt.Read(argForAll, []UpdateArguments{})
			}
		}
	}
	return EmbMapGetValuesState{States: states}
}

func (crdt *RWEmbMapCrdt) getPartialState(updsNotYetApplied []UpdateArguments, args map[string]ReadArguments) (state EmbMapGetValuesState) {
	//Very similar to getState
	//fmt.Println("[RWEmb][EmbMapPartialArguments]Args:", args)
	states := make(map[string]State)
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		for key, arg := range args {
			//fmt.Printf("[RWEmb][EmbMapPartialArguments]Key: %v. Arg: %v (%T)\n", key, arg, arg)
			if embCrdt, has := crdt.entries[key]; has {
				states[key] = embCrdt.Read(arg, updsNotYetApplied)
				//fmt.Printf("[RWEmb][EmbMapPartialArguments]State: %v\n", states[key])
			}
		}
		return EmbMapGetValuesState{States: states}
	}

	applyByCRDT := crdt.prepareApplyByCRDTMap(updsNotYetApplied)

	for key, arg := range args {
		if upds, has := applyByCRDT[key]; has {
			if (upds[0] == NoOp{}) {
				if len(upds) > 1 {
					//Start from scratch
					states[key] = InitializeCrdt((upds[1]).GetCRDTType(),
						crdt.replicaID).Read(StateReadArguments{}, upds[1:])
				} else {
					//Removed CRDT, thus doesn't belong to state
					continue
				}
			} else {
				embCrdt, _ := crdt.getOrCreateEmbCrdt(key, (upds[0]))
				states[key] = embCrdt.Read(StateReadArguments{}, upds)
			}
		} else if embCrdt, has := crdt.entries[key]; has {
			states[key] = embCrdt.Read(arg, []UpdateArguments{})
		}
	}

	return EmbMapGetValuesState{States: states}
}

func (crdt *RWEmbMapCrdt) getKeys(updsNotYetApplied []UpdateArguments) (state MapKeysState) {
	//Literally a copy from ORMap. Sigh
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		keys := make([]string, len(crdt.entries))
		i := 0
		for key := range crdt.entries {
			keys[i] = key
			i++
		}
		return MapKeysState{Keys: keys}
	}

	adds := make(map[string]struct{})
	rems := make(map[string]struct{})

	//Key idea: for each key, the latest update is the only one that matters, hence start at the end.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := (updsNotYetApplied[i]).(type) {
		case EmbMapUpdate:
			if _, has := rems[typedUpd.Key]; !has {
				adds[typedUpd.Key] = struct{}{}
			}
		case MapRemove:
			if _, has := adds[typedUpd.Key]; !has {
				rems[typedUpd.Key] = struct{}{}
			}
		case EmbMapUpdateAll:
			for key := range typedUpd.Upds {
				if _, has := rems[key]; !has {
					adds[key] = struct{}{}
				}
			}
		case EmbMapUpdateAllArray:
			for _, upd := range typedUpd.Upds {
				if _, has := rems[upd.Key]; !has {
					adds[upd.Key] = struct{}{}
				}
			}
		case MapRemoveAll:
			for _, key := range typedUpd.Keys {
				if _, has := adds[key]; !has {
					rems[key] = struct{}{}
				}
			}
		}
	}

	//Build state
	keys := make([]string, len(crdt.entries)+len(adds)-len(rems))
	i := 0
	for key := range crdt.entries {
		if _, has := rems[key]; !has {
			keys[i] = key
			i++
		}
	}
	for key := range adds {
		if _, has := crdt.entries[key]; !has {
			keys[i] = key
			i++
		}
	}
	return MapKeysState{Keys: keys}
}

// Pre: a CRDT associated to key exists
func (crdt *RWEmbMapCrdt) getValue(updsNotYetApplied []UpdateArguments,
	key string, args ReadArguments) (state EmbMapGetValueState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		//Return right away
		inCrdt, has := crdt.entries[key]
		if !has {
			return EmbMapGetValueState{State: RegisterState{Value: ""}}
		}
		/*state := inCrdt.Read(args, updsNotYetApplied).(EmbMapEntryState)
		inCrdtMap := inCrdt.(*RWEmbMapCrdt)
		fmt.Printf("[RWEmbMap][GetValue]Length of state read: %d. Keys of inside CRDT: %d\n", len(state.States), len(inCrdtMap.entries))*/
		return EmbMapGetValueState{State: inCrdt.Read(args, updsNotYetApplied)}
	}

	//Collect all upds for key
	keyUpds := make([]UpdateArguments, min(len(updsNotYetApplied), INITIAL_UPDSNOTAPPLIED_SIZE))
	var noOp UpdateArguments = &NoOp{}
	for _, upd := range updsNotYetApplied {
		switch typedUpd := (upd).(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				keyUpds = append(keyUpds, typedUpd.Upd)
			}
		case EmbMapUpdateAll:
			if upd, has := typedUpd.Upds[key]; has {
				keyUpds = append(keyUpds, upd)
			}
		case EmbMapUpdateAllArray:
			//TODO: Inneficient! But should be okay as EmbMapUpdateAllArray is mostly intended to be used for initial data loading (i.e., no reads in the same transaction)
			for _, upd := range typedUpd.Upds {
				if key == upd.Key {
					keyUpds = append(keyUpds, upd.Upd)
				}
			}
		case MapRemove:
			if key == typedUpd.Key {
				keyUpds = keyUpds[len(keyUpds):]
				keyUpds = append(keyUpds, noOp)
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if key == embKey {
					keyUpds = keyUpds[len(keyUpds):]
					keyUpds = append(keyUpds, noOp)
					break
				}
			}
		}
	}

	var embCrdt CRDT
	var has bool
	if (keyUpds[0] == NoOp{}) {
		//Reset CRDT
		if len(keyUpds) > 1 {
			embCrdt, has = InitializeCrdt((keyUpds[1]).GetCRDTType(), crdt.replicaID), true
			//Hide remove
			keyUpds = keyUpds[1:]
		}
	}
	if !has {
		//Get CRDT from exiting entry
		embCrdt, has = crdt.entries[key]
		if len(keyUpds) == 0 {
			//CRDT doesn't exist and we got no way of knowing which type it was.
			return EmbMapGetValueState{State: RegisterState{Value: nil}}
		} else {
			embCrdt = InitializeCrdt((keyUpds[1]).GetCRDTType(), crdt.replicaID)
		}
	}
	return EmbMapGetValueState{State: embCrdt.Read(args, keyUpds)}
}

func (crdt *RWEmbMapCrdt) hasKey(updsNotYetApplied []UpdateArguments, key string) (state MapHasKeyState) {
	if updsNotYetApplied == nil || len(updsNotYetApplied) == 0 {
		_, has := crdt.entries[key]
		return MapHasKeyState{HasKey: has}
	}

	//Search from finish to end for the "first" op which refers to key.
	for i := len(updsNotYetApplied) - 1; i >= 0; i-- {
		switch typedUpd := (updsNotYetApplied[i]).(type) {
		case EmbMapUpdate:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: true}
			}
		case EmbMapUpdateAll:
			if _, has := typedUpd.Upds[key]; has {
				return MapHasKeyState{HasKey: true}
			}
		case EmbMapUpdateAllArray:
			//TODO: Inneficient! But should be okay as EmbMapUpdateAllArray is mostly intended to be used for initial data loading (i.e., no reads in the same transaction)
			for _, upd := range typedUpd.Upds {
				if key == upd.Key {
					return MapHasKeyState{HasKey: true}
				}
			}
		case MapRemove:
			if key == typedUpd.Key {
				return MapHasKeyState{HasKey: false}
			}
		case MapRemoveAll:
			//TODO: Inneficient!
			for _, embKey := range typedUpd.Keys {
				if embKey == key {
					return MapHasKeyState{HasKey: false}
				}
			}
		}
	}

	//No update for key, so check crdt state
	_, has := crdt.entries[key]
	return MapHasKeyState{HasKey: has}
}

// TODO: Maybe one day implement add and remove with their own methods (i.e., avoid the overhead of creating/handling arrays and maps?)
func (crdt *RWEmbMapCrdt) Update(args UpdateArguments) (downstreamArgs DownstreamArguments) {
	////fmt.Println("Updating:", args)
	switch opType := args.(type) {
	case EmbMapUpdate:
		upds := map[string]UpdateArguments{opType.Key: opType.Upd}
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(upds)
	case MapRemove:
		keys := []string{opType.Key}
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(keys)
	case EmbMapUpdateAll:
		downstreamArgs = crdt.getUpdateAllDownstreamArgs(opType.Upds)
	case MapRemoveAll:
		downstreamArgs = crdt.getRemoveAllDownstreamArgs(opType.Keys)
	case EmbMapUpdateAllArray:
		downstreamArgs = crdt.getUpdateAllDownstreamArgsArray(opType.Upds)
	default:
		fmt.Printf("[RWEmbMap]Didn't apply any update!!! Type received: %T\n", args)
	}
	return
}

func (crdt *RWEmbMapCrdt) getUpdateAllDownstreamArgsArray(upds []EmbMapUpdate) (dowstreamArgs DownstreamArguments) {
	downstreams := make([]KeyDownArgsPair, len(upds))
	written := 0
	rmvEntries := make(map[int16]int64)
	//Get downstream args and highest remove clk
	for _, pairUpd := range upds {
		embCrdt, _ := crdt.getOrCreateEmbCrdt(pairUpd.Key, pairUpd.Upd)
		embUpd := embCrdt.Update(pairUpd.Upd)
		if embUpd == nil {
			fmt.Printf("[RWEmbMapCRDT]GetUpdateAllDownstream. Nil embUpd! %+v. Upd: %+v (Type: %T). key: %s. CRDT: %+v (Type: %T)\n",
				embUpd, pairUpd.Upd, pairUpd.Upd, pairUpd.Key, embCrdt, embCrdt)
		}
		if (embUpd != NoOp{} && embUpd.MustReplicate()) {
			downstreams[written] = KeyDownArgsPair{Key: pairUpd.Key, Upd: embUpd}
			written++
		}
		rmvClk, has := crdt.removes[pairUpd.Key]
		if has {
			for replica, pair := range rmvClk {
				existingClk := rmvEntries[replica]
				if pair.ts > existingClk {
					rmvEntries[replica] = pair.ts
				}
			}
		}
	}

	//May happen due to NuCRDTs. In this case, there's no need to downstream
	if len(downstreams) == 0 && len(rmvEntries) == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapUpdateAllArray{Upds: downstreams[:written], RmvEntries: rmvEntries, ReplicaID: crdt.replicaID}
}

func (crdt *RWEmbMapCrdt) getUpdateAllDownstreamArgs(upds map[string]UpdateArguments) (downstreamArgs DownstreamArguments) {
	downstreams := make(map[string]DownstreamArguments, len(upds))
	rmvEntries := make(map[int16]int64)
	//Get downstream args and highest remove clk
	for key, upd := range upds {
		embCrdt, _ := crdt.getOrCreateEmbCrdt(key, upd)
		embUpd := embCrdt.Update(upd)
		if embUpd == nil {
			fmt.Printf("[RWEmbMapCRDT]GetUpdateAllDownstream. Nil embUpd! %+v. Upd: %+v (Type: %T). key: %s. CRDT: %+v (Type: %T)\n", embUpd, upd, upd, key, embCrdt, embCrdt)
		}
		if (embUpd != NoOp{} && embUpd.MustReplicate()) {
			downstreams[key] = embUpd
		}
		rmvClk, has := crdt.removes[key]
		if has {
			for replica, pair := range rmvClk {
				existingClk := rmvEntries[replica]
				if pair.ts > existingClk {
					rmvEntries[replica] = pair.ts
				}
			}
		}
	}

	//May happen due to NuCRDTs. In this case, there's no need to downstream
	if len(downstreams) == 0 && len(rmvEntries) == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapUpdateAll{Upds: downstreams, RmvEntries: rmvEntries, ReplicaID: crdt.replicaID}
}

func (crdt *RWEmbMapCrdt) getRemoveAllDownstreamArgs(keys []string) (downstreamArgs DownstreamArguments) {
	toRemove := make([]string, len(keys))
	i := 0
	for _, key := range keys {
		if _, has := crdt.entries[key]; has {
			toRemove[i] = key
			i++
		}
	}
	//No CRDT to remove, so an empty op will do
	if i == 0 {
		return NoOp{}
	}
	return DownstreamRWEmbMapRemoveAll{Rems: toRemove[:i], ReplicaID: crdt.replicaID, Ts: crdt.rmvClock.GetPos(crdt.replicaID) + 1}
}

func (crdt *RWEmbMapCrdt) Downstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments) (otherDownstreamArgs DownstreamArguments) {
	////fmt.Println("Downstreaming:", downstreamArgs)
	//When applying downstreams in the emb CRDTs, new ops may be returned from a NuCRDT
	effect, otherDownstreamArgs := crdt.applyDownstream(updTs, downstreamArgs, NORMAL)
	//Necessary for inversibleCrdt
	crdt.addToHistory(&updTs, &downstreamArgs, effect)
	return
}

// Note: When reapplying ops, we need to ensure that we don't replay downstreams in the embedded CRDTs
// Hence the use of the boolean
func (crdt *RWEmbMapCrdt) applyDownstream(updTs clocksi.Timestamp, downstreamArgs DownstreamArguments, isRedo bool) (effect *Effect,
	otherDownstreamArgs DownstreamArguments) {
	var tmpEffect Effect = NoEffect{}
	switch opType := downstreamArgs.(type) {
	case DownstreamRWEmbMapUpdateAll:
		tmpEffect, otherDownstreamArgs = crdt.applyUpdateAll(updTs, opType.Upds, opType.RmvEntries, opType.ReplicaID, isRedo)
	case DownstreamRWEmbMapRemoveAll:
		tmpEffect = crdt.applyRemoveAll(opType.Rems, opType.ReplicaID, opType.Ts)
	case DownstreamRWEmbMapUpdateAllArray:
		tmpEffect, otherDownstreamArgs = crdt.applyUpdateAllArray(updTs, opType.Upds, opType.RmvEntries, opType.ReplicaID, isRedo)
	}
	return &tmpEffect, otherDownstreamArgs
}

func (crdt *RWEmbMapCrdt) applyUpdateAllArray(updTs clocksi.Timestamp, upds []KeyDownArgsPair,
	remClks map[int16]int64, remoteID int16, isRedo bool) (effect *RWEmbMapUpdateAllEffect, otherDownstreamArgs DownstreamArguments) {
	effect = &RWEmbMapUpdateAllEffect{
		Updated:   make([]string, len(upds)),
		ReplicaID: remoteID,
		AddedMark: make(map[string]struct{}),
	}
	newDown := make(map[string]DownstreamArguments) //emb NuCRDTs may generate new downstreams
	updatedIndex := 0

	//Optimized insertion without checking for removes
	if len(crdt.removes) == 0 {
		//If the number of new CRDTs is much higher than the existing ones, force a resize
		//Better than having Go do automatically many small resizes
		//This is specially useful when doing initial load of data.
		if len(upds) >= 1000 && len(upds)/100 > len(crdt.entries) {
			newEntries := make(map[string]CRDT, len(upds)+len(crdt.entries))
			for key, inCrdt := range crdt.entries {
				newEntries[key] = inCrdt
			}
			crdt.entries = newEntries
		}

		//Further optimized insertion
		if len(crdt.entries) == 0 {
			for i, pair := range upds {
				//Store effect, even if it's a redo
				effect.Updated[i] = pair.Key
				if !isRedo {
					// Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
					embCRDT, _ := crdt.getOrCreateEmbCrdt(pair.Key, pair.Upd)
					embDownstream := embCRDT.Downstream(updTs, pair.Upd)
					crdt.entries[pair.Key] = embCRDT
					if embDownstream != nil {
						newDown[pair.Key] = embDownstream
					}
				}
			}
			updatedIndex = len(upds)
		} else {
			for i, pair := range upds {
				//Store effect, even if it's a redo
				effect.Updated[i] = pair.Key
				if !isRedo {
					// Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
					embCRDT, new := crdt.getOrCreateEmbCrdt(pair.Key, pair.Upd)
					embDownstream := embCRDT.Downstream(updTs, pair.Upd)
					if new {
						crdt.entries[pair.Key] = embCRDT
					}
					if embDownstream != nil {
						newDown[pair.Key] = embDownstream
					}
				}
			}
			updatedIndex = len(upds)
		}
	} else {
		//fmt.Println("[ADD]Applying Add from", remoteID, "with remClks", remClks, "and upds", upds)
		for _, pairUpd := range upds {
			remEntry, has := crdt.removes[pairUpd.Key]
			canAdd := !has
			//Remove-wins policy, this add can only have effect if it surparsses all removes.
			if has {
				canAdd = true //If remClks isn't > than remEntry, then canAdd will be set up to false again
				//fmt.Println("[ADD]Have the following removes:", crdt.printMarkedTimestampEntry(remEntry), ". Checking if it can be added with", remClks)
				nMarks := 0
				for replica, pair := range remEntry {
					if remValue, has := remClks[replica]; !has || pair.ts > remValue {
						//fmt.Println("[ADD]Can't add, skipping")
						//Can't apply this update, check next CRDT/upd
						canAdd = false
						break
					} else if pair.mark {
						nMarks++
					}
				}
				if canAdd {
					//fmt.Println("[ADD]Can be added.")
					//Add is after update
					//effect.PreviousRmvs[key] = crdt.removes[key]
					if remotePair, has := remEntry[remoteID]; has {
						if !remotePair.mark {
							effect.AddedMark[pairUpd.Key] = struct{}{}
							remotePair.mark = true
							nMarks++
						}
					}
				}
				if nMarks == len(remEntry) {
					/*
						if effect.PreviousRmvClk == nil {
							effect.PreviousRmvClk = make(map[string]map[int64]*markedTimestamp)
						}
						//The state of the mark is irrelevant to the remove effect, thus the map (and its values' pointers) can be shared
						effect.PreviousRmvClk[key] = crdt.removes[key]
						delete(crdt.removes, key)
					*/
				}

			}
			if canAdd {
				//Store effect, even if it's a redo
				effect.Updated[updatedIndex] = pairUpd.Key
				updatedIndex++
				if !isRedo {
					//Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
					embCRDT, new := crdt.getOrCreateEmbCrdt(pairUpd.Key, pairUpd.Upd)
					embDownstream := embCRDT.Downstream(updTs, pairUpd.Upd)
					if new {
						////fmt.Println("Storing new emb CRDT")
						//fmt.Println("[ADD]Created new CRDT")
						crdt.entries[pairUpd.Key] = embCRDT
					}
					if embDownstream != nil {
						//fmt.Println("[ADD]Embedded generated new downstreams")
						newDown[pairUpd.Key] = embDownstream
					}
				}
			}
		}
	}

	effect.Updated = effect.Updated[:updatedIndex]
	if len(newDown) == 0 {
		//fmt.Println("[ADD]No new downstreams, returning.")
		return effect, nil
	}
	//fmt.Println("[ADD]Got new downstreams!")
	//TODO: is this correct?
	return effect, DownstreamRWEmbMapUpdateAll{Upds: newDown, RmvEntries: make(map[int16]int64)}
}

// Note: Assumes that all updates are for the correct embedded CRDT type
func (crdt *RWEmbMapCrdt) applyUpdateAll(updTs clocksi.Timestamp, upds map[string]DownstreamArguments,
	remClks map[int16]int64, remoteID int16, isRedo bool) (effect *RWEmbMapUpdateAllEffect, otherDownstreamArgs DownstreamArguments) {
	effect = &RWEmbMapUpdateAllEffect{
		Updated:   make([]string, len(upds)),
		ReplicaID: remoteID,
		AddedMark: make(map[string]struct{}),
	}
	newDown := make(map[string]DownstreamArguments) //emb NuCRDTs may generate new downstreams
	updatedIndex := 0

	//Optimized insertion without checking for removes
	if len(crdt.removes) == 0 {
		//If the number of new CRDTs is much higher than the existing ones, force a resize
		//Better than having Go do automatically many small resizes
		//This is specially useful when doing initial load of data.
		if len(upds) >= 1000 && len(upds)/100 > len(crdt.entries) {
			newEntries := make(map[string]CRDT, len(upds)+len(crdt.entries))
			for key, inCrdt := range crdt.entries {
				newEntries[key] = inCrdt
			}
			crdt.entries = newEntries
		}

		//Further optimized insertion
		if len(crdt.entries) == 0 {
			for key, upd := range upds {
				//Store effect, even if it's a redo
				effect.Updated[updatedIndex] = key
				updatedIndex++
				if !isRedo {
					// Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
					embCRDT, _ := crdt.getOrCreateEmbCrdt(key, upd)
					embDownstream := embCRDT.Downstream(updTs, upd)
					crdt.entries[key] = embCRDT
					if embDownstream != nil {
						newDown[key] = embDownstream
					}
				}
			}
		} else {
			for key, upd := range upds {
				//Store effect, even if it's a redo
				effect.Updated[updatedIndex] = key
				updatedIndex++
				if !isRedo {
					// Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
					embCRDT, new := crdt.getOrCreateEmbCrdt(key, upd)
					embDownstream := embCRDT.Downstream(updTs, upd)
					if new {
						crdt.entries[key] = embCRDT
					}
					if embDownstream != nil {
						newDown[key] = embDownstream
					}
				}
			}
		}
	} else {
		//fmt.Println("[ADD]Applying Add from", remoteID, "with remClks", remClks, "and upds", upds)
		for key, upd := range upds {
			remEntry, has := crdt.removes[key]
			canAdd := !has
			//Remove-wins policy, this add can only have effect if it surparsses all removes.
			if has {
				canAdd = true //If remClks isn't > than remEntry, then canAdd will be set up to false again
				//fmt.Println("[ADD]Have the following removes:", crdt.printMarkedTimestampEntry(remEntry), ". Checking if it can be added with", remClks)
				nMarks := 0
				for replica, pair := range remEntry {
					if remValue, has := remClks[replica]; !has || pair.ts > remValue {
						//fmt.Println("[ADD]Can't add, skipping")
						//Can't apply this update, check next CRDT/upd
						canAdd = false
						break
					} else if pair.mark {
						nMarks++
					}
				}
				if canAdd {
					//fmt.Println("[ADD]Can be added.")
					//Add is after update
					//effect.PreviousRmvs[key] = crdt.removes[key]
					if remotePair, has := remEntry[remoteID]; has {
						if !remotePair.mark {
							effect.AddedMark[key] = struct{}{}
							remotePair.mark = true
							nMarks++
						}
					}
				}
				if nMarks == len(remEntry) {
					/*
						if effect.PreviousRmvClk == nil {
							effect.PreviousRmvClk = make(map[string]map[int64]*markedTimestamp)
						}
						//The state of the mark is irrelevant to the remove effect, thus the map (and its values' pointers) can be shared
						effect.PreviousRmvClk[key] = crdt.removes[key]
						delete(crdt.removes, key)
					*/
				}

			}
			if canAdd {
				//Store effect, even if it's a redo
				effect.Updated[updatedIndex] = key
				updatedIndex++
				if !isRedo {
					//Only apply the upd if it isn't a redo (since if it's a redo, we'll just ask the embedded CRDT to rebuild itself by the end)
					embCRDT, new := crdt.getOrCreateEmbCrdt(key, upd)
					embDownstream := embCRDT.Downstream(updTs, upd)
					if new {
						////fmt.Println("Storing new emb CRDT")
						//fmt.Println("[ADD]Created new CRDT")
						crdt.entries[key] = embCRDT
					}
					if embDownstream != nil {
						//fmt.Println("[ADD]Embedded generated new downstreams")
						newDown[key] = embDownstream
					}
				}
			}
		}
	}

	effect.Updated = effect.Updated[:updatedIndex]
	if len(newDown) == 0 {
		//fmt.Println("[ADD]No new downstreams, returning.")
		return effect, nil
	}
	//fmt.Println("[ADD]Got new downstreams!")
	//TODO: is this correct?
	return effect, DownstreamRWEmbMapUpdateAll{Upds: newDown, RmvEntries: make(map[int16]int64)}
}

func (crdt *RWEmbMapCrdt) applyRemoveAll(toRem []string, remoteReplicaID int16, remoteClk int64) (effect *RWEmbMapRemoveAllEffect) {
	effect = &RWEmbMapRemoveAllEffect{
		PreviousClk:  crdt.rmvClock.GetPos(remoteReplicaID),
		ReplicaID:    remoteReplicaID,
		RemovedCRDTs: make(map[string]CRDT),
	}
	//fmt.Println("[REMOVE]Applying Remove from", remoteReplicaID, "with clk", remoteClk)
	crdt.rmvClock.UpdatePos(remoteReplicaID, remoteClk)
	for _, key := range toRem {
		remEntry, has := crdt.removes[key]
		if !has {
			//fmt.Println("[REMOVE]Didn't had any previous remove, making an entry in crdt.removes")
			remEntry = make(map[int16]*markedTimestamp)
			crdt.removes[key] = remEntry
		}
		//fmt.Println("[REMOVE]Stored remove pair for replicaID", remoteReplicaID, "with clk", remoteClk)
		remEntry[remoteReplicaID] = &markedTimestamp{ts: remoteClk, mark: false}
		if len(remEntry) > 1 {
			//fmt.Println("[REMOVE]Resetting entries to non-marked as there's at least 2 replicas")
			//Mark all other entries as not marked
			for _, pair := range remEntry {
				pair.mark = false
			}
		}
		existingCRDT, has := crdt.entries[key]
		if has {
			//fmt.Println("[REMOVE]CRDT existed, removing it.")
			effect.RemovedCRDTs[key] = existingCRDT
			delete(crdt.entries, key)
		} else {
			//fmt.Println("[REMOVE]CRDT didn't exist, no changes.")
		}
	}
	//fmt.Println("[REMOVE]Returning.")
	return
}

func (crdt *RWEmbMapCrdt) IsOperationWellTyped(args UpdateArguments) (ok bool, err error) {
	//TODO: Typechecking
	return true, nil
}

//METHODS FOR INVERSIBLE_CRDT

func (crdt *RWEmbMapCrdt) Copy() (copyCRDT InversibleCRDT) {
	newCrdt := RWEmbMapCrdt{
		CRDTVM:    crdt.CRDTVM.copy(),
		entries:   make(map[string]CRDT),
		removes:   make(map[string]map[int16]*markedTimestamp),
		rmvClock:  crdt.rmvClock.Copy(),
		replicaID: crdt.replicaID,
	}
	for key, embCrdt := range crdt.entries {
		newCrdt.entries[key] = embCrdt.(InversibleCRDT).Copy()
	}
	for key, rmvMap := range crdt.removes {
		newMap := make(map[int16]*markedTimestamp)
		for replica, value := range rmvMap {
			newMap[replica] = &markedTimestamp{ts: value.ts, mark: value.mark}
		}
		newCrdt.removes[key] = newMap
	}

	return &newCrdt
}

func (crdt *RWEmbMapCrdt) RebuildCRDTToVersion(targetTs clocksi.Timestamp) {
	//We'll keep a log of the CRDTs that need to be rebuilt, for efficiency.
	//There's also an opportunity to do so here with multiple goroutines, but that wouldn't be complete
	//and would recalculate old states of CRDTs that were deleted in the past and thus unecessary.
	crdt.keysToRebuild = make(map[string]struct{})
	crdt.CRDTVM.rebuildCRDTToVersion(targetTs)
}

func (crdt *RWEmbMapCrdt) reapplyOp(updArgs DownstreamArguments) (effect *Effect) {
	//The timestamp (nil) is only used by embedded CRDTs, which won't be changed now due to the REDO flag.
	effect, _ = crdt.applyDownstream(nil, updArgs, REDO)
	return effect
}

func (crdt *RWEmbMapCrdt) undoEffect(effect *Effect) {
	switch typedEffect := (*effect).(type) {
	case RWEmbMapUpdateAllEffect:
		crdt.undoUpdateAllEffect(typedEffect.Updated, typedEffect.PreviousRmvClk, typedEffect.AddedMark, typedEffect.ReplicaID)
	case RWEmbMapRemoveAllEffect:
		crdt.undoRemoveAllEffect(typedEffect.RemovedCRDTs, typedEffect.ReplicaID, typedEffect.PreviousClk)
	}
}

func (crdt *RWEmbMapCrdt) undoUpdateAllEffect(updated []string, previousRmvClk map[string]map[int16]*markedTimestamp, addedMark map[string]struct{}, replicaID int16) {
	/*
		//CRDTs that were as removed before this add
		for key, previousClk := range previousRems {
			crdt.removes[key] = previousClk //Should be safe as this is a CRDT copy that won't be changed
			delete(crdt.entries, key)
			delete(crdt.keysToRebuild, key)
		}
		//CRDTs that were updated. Mark them as needed to be updated later
		for _, key := range updated {
			crdt.keysToRebuild[key] = struct{}{}
		}
	*/
	if previousRmvClk != nil {
		for key, entry := range previousRmvClk {
			crdt.removes[key] = entry //Safe since this is a CRDT copy that won't be changed
			delete(crdt.entries, key)
		}
	}
	//Update marks
	for key := range addedMark {
		crdt.removes[key][replicaID].mark = false
	}
	//Update map of CRDTs to be rebuilt
	for _, key := range updated {
		crdt.keysToRebuild[key] = struct{}{}
	}
}

func (crdt *RWEmbMapCrdt) undoRemoveAllEffect(removedCRDTs map[string]CRDT, replicaID int16, previousClk int64) {
	//CRDTs that were removed by this remove. We need to add them back
	for key, embCrdt := range removedCRDTs {
		crdt.entries[key] = embCrdt
		delete(crdt.removes, key)
	}
	crdt.rmvClock.UpdateForcedPos(replicaID, previousClk)
}

func (crdt *RWEmbMapCrdt) notifyRebuiltComplete(currTs *clocksi.Timestamp) {
	//Only redo CRDTs that were altered
	for key := range crdt.keysToRebuild {
		crdt.entries[key].(InversibleCRDT).RebuildCRDTToVersion(*currTs)
	}
	crdt.keysToRebuild = nil
}

//Others

func (crdt *RWEmbMapCrdt) getOrCreateEmbCrdt(key string, upd UpdateArguments) (embCrdt CRDT, new bool) {
	embCrdt, has := crdt.entries[key]
	new = !has
	if !has {
		embCrdt = InitializeCrdt(upd.GetCRDTType(), crdt.replicaID)
		/*if embCrdt.GetCRDTType() == proto.CRDTType_ORMAP {
			fmt.Printf("[RWEmbMap][GetOrCreateEmbCrdt]Created a new ORMAP!!! Upd: %+v (Type: %T); Key %s. EmbCRDT: %+v (Type: %T)\n",
				upd, upd, key, embCrdt, embCrdt)
			panic("[RWEmbMap][GetOrCreateEmbMapCrdt]Created ORMAP panic.")
		}*/
	} /*else if embCrdt.GetCRDTType() == proto.CRDTType_ORMAP {
		fmt.Printf("[RWEmbMap][GetOrCreateEmbCrdt]Returning existing ORMAP!!! Upd: %+v (Type: %T); Key %s. EmbCRDT: %+v (Type: %T)\n",
			upd, upd, key, embCrdt, embCrdt)
		panic("[RWEmbMap][GetOrCreateEmbMapCrdt]Read ORMAP panic.")
	}*/
	return
}

//Debug, delete this

func (crdt *RWEmbMapCrdt) printMarkedTimestampEntry(entry map[int64]*markedTimestamp) (text string) {
	var builder strings.Builder
	builder.WriteString("map[")
	for key, pair := range entry {
		builder.WriteString(fmt.Sprint(key))
		builder.WriteRune(':')
		builder.WriteString(fmt.Sprint(*pair))
		builder.WriteRune(' ')
	}
	builder.WriteRune(']')
	return builder.String()
}

//Protobuf functions
//Note: the states/ops common with OrMap are defined there

func (crdtOp EmbMapUpdateAll) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	protoAdds := protobuf.GetMapop().GetUpdates()
	crdtOp.Upds = make(map[string]UpdateArguments)
	for _, mapUpd := range protoAdds {
		crdtOp.Upds[string(mapUpd.GetKey().GetKey())] =
			UpdateProtoToAntidoteUpdate(mapUpd.GetUpdate(), mapUpd.GetKey().GetType())
	}
	return crdtOp
}

func (crdtOp EmbMapUpdateAll) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Mapop: &proto.ApbMapUpdate{Updates: createMapNestedOps(crdtOp.Upds), RemovedKeys: []*proto.ApbMapKey{}}}
}

func (crdtOp EmbMapUpdateAllArray) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	protoAdds := protobuf.GetMapop().GetUpdates()
	crdtOp.Upds = make([]EmbMapUpdate, len(protoAdds))
	for i, mapUpd := range protoAdds {
		crdtOp.Upds[i] = EmbMapUpdate{Key: string(mapUpd.GetKey().GetKey()),
			Upd: UpdateProtoToAntidoteUpdate(mapUpd.GetUpdate(), mapUpd.GetKey().GetType())}
	}
	return crdtOp
}

func (crdtOp EmbMapUpdateAllArray) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Mapop: &proto.ApbMapUpdate{Updates: createSliceNestedOps(crdtOp.Upds), RemovedKeys: []*proto.ApbMapKey{}}}
}

func (crdtOp EmbMapUpdate) FromUpdateObject(protobuf *proto.ApbUpdateOperation) (op UpdateArguments) {
	protoAdd := protobuf.GetMapop().GetUpdates()[0]
	crdtOp.Key = string(protoAdd.GetKey().GetKey())
	crdtOp.Upd = UpdateProtoToAntidoteUpdate(protoAdd.GetUpdate(), protoAdd.GetKey().GetType())
	return crdtOp
}

func (crdtOp EmbMapUpdate) ToUpdateObject() (protobuf *proto.ApbUpdateOperation) {
	return &proto.ApbUpdateOperation{Mapop: &proto.ApbMapUpdate{
		Updates:     createMapNestedOps(map[string]UpdateArguments{crdtOp.Key: crdtOp.Upd}),
		RemovedKeys: []*proto.ApbMapKey{},
	}}
}

func (crdtState EmbMapEntryState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {

	/*
		if entries := protobuf.GetMap().GetEntries(); entries != nil {
			var pKey *proto.ApbMapKey
			for _, entry := range entries {
				pKey = entry.GetKey()
				//In this case the inner reads are also full read for sure. Might be worth changing this in the future though.
				crdtState.States[string(pKey.GetKey())] = ReadRespProtoToAntidoteState(entry.GetValue(), pKey.GetType(), proto.READType_FULL)
			}
		} else {
			//Partial read
			mapProto := protobuf.GetPartread().GetMap().GetGetvalues()
			protoKeys, protoValues := mapProto.GetKeys(), mapProto.GetValues()
			for i, protoValue := range protoValues {
				innerCrdtType, innerReadType := protoValue.GetCrdttype(), protoValue.GetParttype()
				crdtState.States[string(protoKeys[i])] = ReadRespProtoToAntidoteState(protoValue.GetValue(), innerCrdtType, innerReadType)
			}
		}
	*/
	entries := protobuf.GetMap().GetEntries()
	crdtState.States = make(map[string]State, len(entries))
	var pKey *proto.ApbMapKey
	for _, entry := range entries {
		pKey = entry.GetKey()
		//In this case the inner reads are also full read for sure. Might be worth changing this in the future though.
		crdtState.States[string(pKey.GetKey())] = ReadRespProtoToAntidoteState(entry.GetValue(), pKey.GetType(), proto.READType_FULL)
	}

	return crdtState
}

func (crdtState EmbMapEntryState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	return &proto.ApbReadObjectResp{Map: &proto.ApbGetMapResp{Entries: crdtsToApbMapEntries(crdtState.States)}}
}

func (crdtState EmbMapHasKeyState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	crdtState.HasKey = protobuf.GetPartread().GetMap().GetHaskey().GetHas()
	return crdtState
}

func (crdtState EmbMapHasKeyState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	return &proto.ApbReadObjectResp{Partread: &proto.ApbPartialReadResp{Map: &proto.ApbMapPartialReadResp{
		Haskey: &proto.ApbMapHasKeyReadResp{Has: pb.Bool(crdtState.HasKey)},
	}}}
}

func (crdtState EmbMapKeysState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	crdtState.Keys = protobuf.GetPartread().GetMap().GetGetkeys().GetKeys()
	return crdtState
}

func (crdtState EmbMapKeysState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	return &proto.ApbReadObjectResp{Partread: &proto.ApbPartialReadResp{Map: &proto.ApbMapPartialReadResp{
		Getkeys: &proto.ApbMapGetKeysReadResp{Keys: crdtState.Keys},
	}}}
}

func (crdtState EmbMapGetValueState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	mapProto := protobuf.GetPartread().GetMap().GetGetvalue()
	innerCrdtType, innerReadType := mapProto.GetCrdttype(), mapProto.GetParttype()
	crdtState.State = ReadRespProtoToAntidoteState(mapProto.GetValue(), innerCrdtType, innerReadType)
	return crdtState
}

func (crdtState EmbMapGetValueState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	innerCrdtType, innerReadType := crdtState.State.GetCRDTType(), crdtState.State.GetREADType()
	return &proto.ApbReadObjectResp{Partread: &proto.ApbPartialReadResp{Map: &proto.ApbMapPartialReadResp{
		Getvalue: &proto.ApbMapGetValueResp{
			Value: crdtState.State.(ProtoState).ToReadResp(), Crdttype: &innerCrdtType, Parttype: &innerReadType,
		},
	}}}
}

func (crdtState EmbMapGetValuesState) FromReadResp(protobuf *proto.ApbReadObjectResp) (state State) {
	mapProto := protobuf.GetPartread().GetMap().GetGetvalues()
	protoKeys, protoValues := mapProto.GetKeys(), mapProto.GetValues()
	crdtState.States = make(map[string]State, len(protoKeys))
	var innerProto *proto.ApbMapGetValueResp
	for i, key := range protoKeys {
		innerProto = protoValues[i]
		crdtState.States[string(key)] = ReadRespProtoToAntidoteState(innerProto.GetValue(), innerProto.GetCrdttype(), innerProto.GetParttype())
	}
	return crdtState
}

func (crdtState EmbMapGetValuesState) ToReadResp() (protobuf *proto.ApbReadObjectResp) {
	//fmt.Printf("[RWEmb][EmbMapGetValuesState]ToReadResp(). States: %+v\n", crdtState.States)
	keys, values := make([][]byte, len(crdtState.States)), make([]*proto.ApbMapGetValueResp, len(crdtState.States))
	i := 0
	for key, state := range crdtState.States {
		crdtType, readType := state.GetCRDTType(), state.GetREADType()
		keys[i], values[i] = []byte(key), &proto.ApbMapGetValueResp{Crdttype: &crdtType, Parttype: &readType, Value: state.(ProtoState).ToReadResp()}
		i++
	}
	//fmt.Printf("[RWEmb][EmbMapGetValuesState]ToReadResp end. Keys: %+v, Values: %+v\n", keys, values)
	return &proto.ApbReadObjectResp{Partread: &proto.ApbPartialReadResp{Map: &proto.ApbMapPartialReadResp{
		Getvalues: &proto.ApbMapGetValuesResp{Keys: keys, Values: values}}}}
}

func (args EmbMapGetValueArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	getValueProto := protobuf.GetMap().GetGetvalue()
	protoArgs := getValueProto.GetArgs()
	if protoArgs == nil {
		//Read whole inner state
		return EmbMapGetValueArguments{Key: string(getValueProto.GetKey()), Args: StateReadArguments{}}
	}
	//Read part of inner state
	innerCrdtType, innerReadType := protoArgs.GetType(), protoArgs.GetReadtype()
	args.Key = string(getValueProto.GetKey())
	args.Args = *PartialReadOpToAntidoteRead(protoArgs.GetArgs(), innerCrdtType, innerReadType)
	return args
}

func (args EmbMapPartialArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	getValuesProto := protobuf.GetMap().GetGetvalues()
	byteKeys, argsProto := getValuesProto.GetKeys(), getValuesProto.GetArgs()
	args.Args = make(map[string]ReadArguments, len(byteKeys))

	for i, argProto := range argsProto {
		args.Args[string(byteKeys[i])] = *PartialReadOpToAntidoteRead(argProto.GetArgs(), argProto.GetType(), argProto.GetReadtype())
	}
	return args
}

func (args EmbMapPartialOnAllArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	argProto := protobuf.GetMap().GetGetallvalues().GetArgs()
	return EmbMapPartialOnAllArguments{ArgForAll: *PartialReadOpToAntidoteRead(argProto.GetArgs(), argProto.GetType(), argProto.GetReadtype())}
}

func (args EmbMapExceptArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	exceptProto := protobuf.GetMap().GetExceptread()
	protoKeys, protoArgs := exceptProto.GetKeys(), exceptProto.GetArgs()
	args.ExceptKeys = make(map[string]struct{}, len(protoKeys))
	for _, byteKey := range protoKeys {
		args.ExceptKeys[string(byteKey)] = struct{}{}
	}
	if protoArgs == nil {
		args.ArgForAll = StateReadArguments{}
	} else {
		args.ArgForAll = *PartialReadOpToAntidoteRead(protoArgs.GetArgs(), protoArgs.GetType(), protoArgs.GetReadtype())
	}
	return args
}

func (args EmbMapConditionalReadArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	protoArgs := protobuf.GetMap().GetCondread().GetCondargs()
	condArgs := make(map[string]CompareArguments, len(protoArgs))
	var key string
	var condArg CompareArguments
	for _, protoArg := range protoArgs {
		key, condArg = protoArgsToCompareArgsHelper(protoArg)
		condArgs[key] = condArg
	}
	return EmbMapConditionalReadArguments{CondArgs: condArgs}
}

func (args EmbMapConditionalReadAllArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	_, condArg := protoArgsToCompareArgsHelper(protobuf.GetMap().GetCondallread().GetCondarg())
	return EmbMapConditionalReadAllArguments{CompareArguments: condArg}
}

func (args EmbMapConditionalReadExceptArguments) FromPartialRead(protobuf *proto.ApbPartialReadArgs) (readArgs ReadArguments) {
	condProto := protobuf.GetMap().GetExceptcondread()
	_, condArg := protoArgsToCompareArgsHelper(condProto.GetCondarg())
	protoKeys := condProto.GetKeys()
	keys := make(map[string]struct{}, len(protoKeys))
	for _, keyBytes := range protoKeys {
		keys[string(keyBytes)] = struct{}{}
	}
	return EmbMapConditionalReadExceptArguments{ExceptKeys: keys, CondArgForAll: condArg}
}

func protoArgsToCompareArgsHelper(protoArg *proto.ApbMapCondArgs) (key string, condArg CompareArguments) {
	key = protoArg.GetKey()
	if intComp := protoArg.GetIntcomp(); intComp != nil {
		condArg = &IntCompareArguments{Value: intComp.GetValue(), CompType: CompType(intComp.GetComp())}
	} else if floatComp := protoArg.GetFloatcomp(); floatComp != nil {
		condArg = &FloatCompareArguments{Value: floatComp.GetValue(), CompType: CompType(floatComp.GetComp())}
	} else if noComp := protoArg.GetNocomp(); noComp != nil {
		condArg = &GetNoCompareArguments{}
	} else if mapComp := protoArg.GetMapcomp(); mapComp != nil {
		mapArgs := make(map[string]CompareArguments)
		var mapKey string
		for _, entry := range mapComp.GetValue() {
			mapKey, condArg = protoArgsToCompareArgsHelper(entry)
			mapArgs[mapKey] = condArg
		}
		condArg = &MapCompareArguments{MapArgs: mapArgs}
	} else if stringComp := protoArg.GetStringcomp(); stringComp != nil {
		condArg = &StringCompareArguments{Value: stringComp.GetValue(), IsEqualComp: stringComp.GetIsEqualComp()}
	} else if boolComp := protoArg.GetBoolcomp(); boolComp != nil {
		condArg = &BoolCompareArguments{Value: boolComp.GetValue(), IsEqualComp: boolComp.GetIsEqualComp()}
	} else {
		bytesComp := protoArg.GetBytescomp()
		condArg = &BytesCompareArguments{Value: bytesComp.GetValue(), IsEqualComp: bytesComp.GetIsEqualComp()}
	}
	return
}

func (args EmbMapGetValueArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Getvalue: &proto.ApbMapGetValueRead{
		Key:  []byte(args.Key),
		Args: createMapGetValuesRead(args.Args),
	}}}
}

func (args EmbMapPartialArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	keys := make([][]byte, len(args.Args))
	argsProtos := make([]*proto.ApbMapEmbPartialArgs, len(args.Args))
	i := 0
	for key, arg := range args.Args {
		keys[i] = []byte(key)
		argsProtos[i] = createMapGetValuesRead(arg)
		i++
	}

	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Getvalues: &proto.ApbMapGetValuesRead{Keys: keys, Args: argsProtos}}}
}

func (args EmbMapPartialOnAllArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	argProto := createMapGetValuesRead(args.ArgForAll)
	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Getallvalues: &proto.ApbMapGetAllValuesRead{Args: argProto}}}
}

func (args EmbMapExceptArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	exceptProto := proto.ApbMapExceptRead{Keys: make([][]byte, len(args.ExceptKeys))}
	i := 0
	for key := range args.ExceptKeys {
		exceptProto.Keys[i] = []byte(key)
		i++
	}
	if args.ArgForAll == nil {
		return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Exceptread: &exceptProto}}
	}
	exceptProto.Args = createMapGetValuesRead(args.ArgForAll)
	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Exceptread: &exceptProto}}
}

func (args EmbMapConditionalReadArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	protoArgs := make([]*proto.ApbMapCondArgs, len(args.CondArgs))
	i := 0
	for key, compArgs := range args.CondArgs {
		protoArgs[i] = &proto.ApbMapCondArgs{}
		compareArgsToProtoHelper(key, compArgs, protoArgs[i])
		i++
	}
	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Condread: &proto.ApbMapCondRead{Condargs: protoArgs}}}
}

func (args EmbMapConditionalReadAllArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	protoArg := &proto.ApbMapCondArgs{}
	compareArgsToProtoHelper("", args.CompareArguments, protoArg)
	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Condallread: &proto.ApbMapAllCondRead{Condarg: protoArg}}}
}

func (args EmbMapConditionalReadExceptArguments) ToPartialRead() (protobuf *proto.ApbPartialReadArgs) {
	protoArg := &proto.ApbMapCondArgs{}
	compareArgsToProtoHelper("", args.CondArgForAll, protoArg)
	keys, i := make([][]byte, len(args.ExceptKeys)), 0
	for key := range args.ExceptKeys {
		keys[i] = []byte(key)
		i++
	}
	return &proto.ApbPartialReadArgs{Map: &proto.ApbMapPartialRead{Exceptcondread: &proto.ApbMapExceptCondRead{Keys: keys, Condarg: protoArg}}}
}

func compareArgsToProtoHelper(key string, args CompareArguments, protobuf *proto.ApbMapCondArgs) {
	if key != "" {
		protobuf.Key = pb.String(key)
	}
	var compType proto.COMPType
	switch typedArgs := args.(type) {
	case *IntCompareArguments:
		compType = proto.COMPType(typedArgs.CompType)
		protobuf.Intcomp = &proto.ApbCondIntCompare{Value: pb.Int64(typedArgs.Value), Comp: &compType}
	case *FloatCompareArguments:
		compType = proto.COMPType(typedArgs.CompType)
		protobuf.Floatcomp = &proto.ApbCondFloatCompare{Value: pb.Float64(typedArgs.Value), Comp: &compType}
	case *MapCompareArguments:
		protobuf.Mapcomp = &proto.ApbCondMapCompare{Value: make([]*proto.ApbMapCondArgs, len(typedArgs.MapArgs))}
		i := 0
		for key, args := range typedArgs.MapArgs {
			protobuf.Mapcomp.Value[i] = &proto.ApbMapCondArgs{}
			compareArgsToProtoHelper(key, args, protobuf.Mapcomp.Value[i])
			i++
		}
	case *BoolCompareArguments:
		protobuf.Boolcomp = &proto.ApbCondBoolCompare{Value: pb.Bool(typedArgs.Value), IsEqualComp: &typedArgs.IsEqualComp}
	case *StringCompareArguments:
		protobuf.Stringcomp = &proto.ApbCondStringCompare{Value: pb.String(typedArgs.Value), IsEqualComp: &typedArgs.IsEqualComp}
	case *BytesCompareArguments:
		protobuf.Bytescomp = &proto.ApbCondBytesCompare{Value: typedArgs.Value, IsEqualComp: &typedArgs.IsEqualComp}
	case *GetNoCompareArguments:
		protobuf.Nocomp = &proto.ApbCondGetNoCompare{}
	}
}

func (downOp DownstreamRWEmbMapUpdateAll) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	adds := protobuf.GetRwembmapOp().GetAdds()
	upds, clk := adds.GetUpds(), adds.GetVc()
	downOp.Upds, downOp.RmvEntries, downOp.ReplicaID = make(map[string]DownstreamArguments, len(upds)), make(map[int16]int64, len(clk)), int16(adds.GetReplicaID())

	for _, upd := range upds {
		downOp.Upds[string(upd.GetKey())] = DownstreamProtoToAntidoteDownstream(upd.GetUpd(), upd.GetType())
	}
	for _, protoEntry := range clk {
		downOp.RmvEntries[int16(protoEntry.GetSenderID())] = protoEntry.GetReplicaTs()
	}
	return downOp
}

func (downOp DownstreamRWEmbMapRemoveAll) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	rems := protobuf.GetRwembmapOp().GetRems()
	downOp.Rems, downOp.Ts, downOp.ReplicaID = rems.GetKeys(), rems.GetTs(), int16(rems.GetReplicaID())
	return downOp
}

func (downOp DownstreamRWEmbMapUpdateAllArray) FromReplicatorObj(protobuf *proto.ProtoOpDownstream) (downArgs DownstreamArguments) {
	adds := protobuf.GetRwembmapOp().GetAdds()
	upds, clk, replicaID := adds.GetUpds(), adds.GetVc(), int16(adds.GetReplicaID())
	if len(upds) >= 40000 {
		return downOp.FromReplicatorObjHelper(upds, clk, replicaID)
	}
	downOp.Upds, downOp.RmvEntries, downOp.ReplicaID = make([]KeyDownArgsPair, len(upds)), make(map[int16]int64, len(clk)), replicaID

	for i, upd := range upds {
		downOp.Upds[i] = KeyDownArgsPair{Key: string(upd.GetKey()), Upd: DownstreamProtoToAntidoteDownstream(upd.GetUpd(), upd.GetType())}
	}
	for _, protoEntry := range clk {
		downOp.RmvEntries[int16(protoEntry.GetSenderID())] = protoEntry.GetReplicaTs()
	}
	return downOp
}

func (downOp DownstreamRWEmbMapUpdateAllArray) FromReplicatorObjHelper(upds []*proto.ProtoEmbMapUpd, clk []*proto.ProtoStableClock, replicaID int16) (downArgs DownstreamArguments) {
	//start := time.Now()
	//fmt.Printf("[RWEmbMap][DownstreamRWEmbMapUpdAllArray]FromReplicatorObjHelper(). Size of upds: %d. Start time: %s. \n", len(upds), start.Format("2006-01-02 15:04:05.000"))
	//E.g: upds = 110000. nParts = 5. nFactor = 22000.
	nParts := min(len(upds)/20000, 32)
	nFactor := len(upds) / nParts
	replyChan := make(chan bool, nParts)
	downOp.Upds, downOp.RmvEntries, downOp.ReplicaID = make([]KeyDownArgsPair, len(upds)), make(map[int16]int64, len(clk)), replicaID
	for i := 0; i < nParts; i++ {
		go func(start, end int) {
			var upd *proto.ProtoEmbMapUpd
			for ; start < end; start++ {
				upd = upds[start]
				downOp.Upds[start] = KeyDownArgsPair{Key: string(upd.GetKey()), Upd: DownstreamProtoToAntidoteDownstream(upd.GetUpd(), upd.GetType())}
			}
			replyChan <- true
		}(i*nFactor, (i+1)*nFactor)
	}
	var upd *proto.ProtoEmbMapUpd
	for k := nFactor * nParts; k < len(downOp.Upds); k++ {
		upd = upds[k]
		downOp.Upds[k] = KeyDownArgsPair{Key: string(upd.GetKey()), Upd: DownstreamProtoToAntidoteDownstream(upd.GetUpd(), upd.GetType())}
	}
	for _, protoEntry := range clk {
		downOp.RmvEntries[int16(protoEntry.GetSenderID())] = protoEntry.GetReplicaTs()
	}
	for i := 0; i < nParts; i++ {
		<-replyChan
	}
	/*end := time.Now()
	fmt.Printf("[RWEmbMap[DownstreamRWEmbMapUpdAllArray]FromReplicatorObjHelper(). Size of upds: %d. Start time: %s. End time: %s. Duration: %d (ms).\n", len(downOp.Upds), start.Format("2006-01-02 15:04:05.000"),
		end.Format("2006-01-02 15:04:05.000"), (end.UnixNano()-start.UnixNano())/1000000)*/
	return downOp
}

func (downOp DownstreamRWEmbMapUpdateAll) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	upds, vc := make([]*proto.ProtoEmbMapUpd, len(downOp.Upds)), make([]*proto.ProtoStableClock, len(downOp.RmvEntries))
	i, j := 0, 0
	for key, upd := range downOp.Upds {
		crdtType := upd.GetCRDTType()
		upds[i] = &proto.ProtoEmbMapUpd{Key: []byte(key), Type: &crdtType, Upd: upd.(ProtoDownUpd).ToReplicatorObj()}
		i++
	}
	for key, clk := range downOp.RmvEntries {
		vc[j] = &proto.ProtoStableClock{SenderID: pb.Int32(int32(key)), ReplicaTs: pb.Int64(clk)}
		j++
	}
	return &proto.ProtoOpDownstream{RwembmapOp: &proto.ProtoRWEmbMapDownstream{
		Adds: &proto.ProtoRWEmbMapUpdates{Upds: upds, Vc: vc, ReplicaID: pb.Int32(int32(downOp.ReplicaID))},
	}}
}

func (downOp DownstreamRWEmbMapRemoveAll) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	return &proto.ProtoOpDownstream{RwembmapOp: &proto.ProtoRWEmbMapDownstream{
		Rems: &proto.ProtoRWEmbMapRemoves{Keys: downOp.Rems, ReplicaID: pb.Int32(int32(downOp.ReplicaID)), Ts: pb.Int64(downOp.Ts)},
	}}
}

func (downOp DownstreamRWEmbMapUpdateAllArray) ToReplicatorObjHelper() (protobuf *proto.ProtoOpDownstream) {
	//start := time.Now()
	//fmt.Printf("[RWEmbMap][DownstreamRWEmbMapUpdAllArray]ToReplicatorObjHelper(). Size of upds: %d. Start time: %s. \n", len(downOp.Upds), start.Format("2006-01-02 15:04:05.000"))
	//E.g: upds = 110000. nParts = 5. nFactor = 22000.
	nParts := min(len(downOp.Upds)/20000, 32)
	nFactor := len(downOp.Upds) / nParts
	replyChan := make(chan bool, nParts)
	upds, vc := make([]*proto.ProtoEmbMapUpd, len(downOp.Upds)), make([]*proto.ProtoStableClock, len(downOp.RmvEntries))
	for i := 0; i < nParts; i++ {
		go func(start, end int) {
			var currUpd KeyDownArgsPair
			for ; start < end; start++ {
				currUpd = downOp.Upds[start]
				crdtType := currUpd.Upd.GetCRDTType()
				upds[start] = &proto.ProtoEmbMapUpd{Key: []byte(currUpd.Key), Type: &crdtType, Upd: currUpd.Upd.(ProtoDownUpd).ToReplicatorObj()}
			}
			replyChan <- true
		}(i*nFactor, (i+1)*nFactor)
	}
	for k := nFactor * nParts; k < len(downOp.Upds); k++ {
		currUpd := downOp.Upds[k]
		crdtType := currUpd.Upd.GetCRDTType()
		upds[k] = &proto.ProtoEmbMapUpd{Key: []byte(currUpd.Key), Type: &crdtType, Upd: currUpd.Upd.(ProtoDownUpd).ToReplicatorObj()}
	}
	j := 0
	for key, clk := range downOp.RmvEntries {
		vc[j] = &proto.ProtoStableClock{SenderID: pb.Int32(int32(key)), ReplicaTs: pb.Int64(clk)}
		j++
	}
	for i := 0; i < nParts; i++ {
		<-replyChan
	}
	//end := time.Now()
	//fmt.Printf("[RWEmbMap[DownstreamRWEmbMapUpdAllArray]ToReplicatorObjHelper(). Size of upds: %d. Start time: %s. End time: %s. Duration: %d (ms).\n", len(downOp.Upds), start.Format("2006-01-02 15:04:05.000"),
	//end.Format("2006-01-02 15:04:05.000"), (end.UnixNano()-start.UnixNano())/1000000)
	return &proto.ProtoOpDownstream{RwembmapOp: &proto.ProtoRWEmbMapDownstream{
		Adds: &proto.ProtoRWEmbMapUpdates{Upds: upds, Vc: vc, ReplicaID: pb.Int32(int32(downOp.ReplicaID)), IsArray: pb.Bool(true)},
	}}

}

func (downOp DownstreamRWEmbMapUpdateAllArray) ToReplicatorObj() (protobuf *proto.ProtoOpDownstream) {
	if len(downOp.Upds) >= 40000 {
		return downOp.ToReplicatorObjHelper()
	}
	/*var start, end time.Time
	if len(downOp.Upds) >= 50 {
		start = time.Now()
		fmt.Printf("[RWEmbMap][DownstreamRWEmbMapUpdAllArray]ToReplicatorObj(). Size of upds: %d. Start time: %s. \n", len(downOp.Upds), start.Format("2006-01-02 15:04:05.000"))
	}*/
	upds, vc := make([]*proto.ProtoEmbMapUpd, len(downOp.Upds)), make([]*proto.ProtoStableClock, len(downOp.RmvEntries))
	j := 0
	for i, upd := range downOp.Upds {
		crdtType := upd.Upd.GetCRDTType()
		upds[i] = &proto.ProtoEmbMapUpd{Key: []byte(upd.Key), Type: &crdtType, Upd: upd.Upd.(ProtoDownUpd).ToReplicatorObj()}
	}
	for key, clk := range downOp.RmvEntries {
		vc[j] = &proto.ProtoStableClock{SenderID: pb.Int32(int32(key)), ReplicaTs: pb.Int64(clk)}
		j++
	}
	/*if len(downOp.Upds) >= 50 {
		end = time.Now()
		fmt.Printf("[RWEmbMap[DownstreamRWEmbMapUpdAllArray]ToReplicatorObj(). Size of upds: %d. Start time: %s. End time: %s. Duration: %d (ms).\n", len(downOp.Upds), start.Format("2006-01-02 15:04:05.000"),
			end.Format("2006-01-02 15:04:05.000"), (end.UnixNano()-start.UnixNano())/1000000)
	}*/
	return &proto.ProtoOpDownstream{RwembmapOp: &proto.ProtoRWEmbMapDownstream{
		Adds: &proto.ProtoRWEmbMapUpdates{Upds: upds, Vc: vc, ReplicaID: pb.Int32(int32(downOp.ReplicaID)), IsArray: pb.Bool(true)},
	}}
}

func (crdt *RWEmbMapCrdt) ToProtoState() (protobuf *proto.ProtoState) {
	protoCRDTs, protoRems, protoClk := make([]*proto.ProtoEmbMapEntry, len(crdt.entries)), make([]*proto.ProtoEmbMapRemove, len(crdt.removes)), crdt.rmvClock.ToBytes()
	i, j, k := 0, 0, 0
	var currRmvClk []*proto.ProtoStableClock
	for key, crdt := range crdt.entries {
		crdtType := crdt.GetCRDTType()
		protoCRDTs[i] = &proto.ProtoEmbMapEntry{Key: &key, Type: &crdtType, State: (crdt.(ProtoCRDT)).ToProtoState()}
		i++
	}
	for key, rmvMap := range crdt.removes {
		currRmvClk = make([]*proto.ProtoStableClock, len(rmvMap))
		for replicaID, markedTs := range rmvMap {
			currRmvClk[k] = &proto.ProtoStableClock{SenderID: pb.Int32(int32(replicaID)), ReplicaTs: &markedTs.ts}
			k++
		}
		protoRems[j] = &proto.ProtoEmbMapRemove{Key: &key, Clks: currRmvClk}
		j++
	}

	return &proto.ProtoState{Embmap: &proto.ProtoEmbMapState{Crdts: protoCRDTs, Removes: protoRems, RmvClock: protoClk}}
}

func (crdt *RWEmbMapCrdt) FromProtoState(proto *proto.ProtoState, ts *clocksi.Timestamp, replicaID int16) (newCRDT CRDT) {
	protoMap := proto.GetEmbmap()
	protoCRDTs, protoRmvs, protoClk := protoMap.GetCrdts(), protoMap.GetRemoves(), protoMap.GetRmvClock()
	entries, removes := make(map[string]CRDT, len(protoCRDTs)), make(map[string]map[int16]*markedTimestamp, len(protoRmvs))
	var currRmvMap map[int16]*markedTimestamp
	for _, protoEntry := range protoCRDTs {
		entries[protoEntry.GetKey()] = StateProtoToCrdt(protoEntry.GetState(), protoEntry.GetType(), ts, replicaID)
	}
	for _, protoRmv := range protoRmvs {
		currRmvMap = make(map[int16]*markedTimestamp)
		for _, clkProto := range protoRmv.GetClks() {
			currRmvMap[int16(clkProto.GetSenderID())] = &markedTimestamp{ts: clkProto.GetReplicaTs(), mark: true}
		}
		removes[protoRmv.GetKey()] = currRmvMap
	}

	return (&RWEmbMapCrdt{entries: entries, removes: removes, rmvClock: clocksi.ClockSiTimestamp{}.FromBytes(protoClk),
		replicaID: crdt.replicaID}).initializeFromSnapshot(ts, replicaID)
}

func (crdt *RWEmbMapCrdt) GetCRDT() CRDT { return crdt }
